\documentclass{report}

\usepackage{standalone}

\usepackage[bookmarks=true]{hyperref}

% symbols
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb} % for \square

% from http://tex.stackexchange.com/a/5255
\DeclareMathOperator*{\argmin}{arg\,min}

% algorithm stuff
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{array}
\usepackage{graphicx}
\usepackage{subcaption}

\usepackage{tikz}
\usetikzlibrary{arrows,backgrounds,calc,patterns,positioning,shapes,decorations.pathmorphing}

% plots
\usepackage{pgfplots}

% pretty tables
\usepackage{multirow}
\usepackage{booktabs}

% custom title page
\usepackage{titling}

% for adjustwidth
\usepackage{changepage}

% simple paragraph stuff
\parindent=0pt
\parskip=6pt

% include \paragraph as numbered
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{2} % 3

%\def\hidenotes{}
% list of commenters
\newcommand{\ssnote}[1]{{\xxnote{SS}{red}{#1}}}
\newcommand{\cdnote}[1]{{\xxnote{CD}{blue}{#1}}}
\newcommand{\mknote}[1]{{\xxnote{MK}{green}{#1}}}
% implement conditional notes (turn on/off with \hidenotes above)
\newcommand{\xxnote}[3]{}
\ifx\hidenotes\undefined
  \usepackage{color}
  \renewcommand{\xxnote}[3]{\color{#2}{#1: #3}}
\fi

% wide page for side by side figures, tables, etc
% see http://tex.stackexchange.com/a/154766
\newlength{\offsetpage}
\setlength{\offsetpage}{1.5in}
\newenvironment{widepage}
   {\begin{adjustwidth}{-\offsetpage}{-\offsetpage}%
    \addtolength{\textwidth}{2\offsetpage}}%
{\end{adjustwidth}}

% theorems
\newtheorem{invariant}{Invariant}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
% from http://www.maths.tcd.ie/~dwilkins/LaTeXPrimer/Theorems.html
\newenvironment{proof}[1][Proof]{\begin{trivlist}
   \item[\hskip \labelsep {\bfseries #1}]}{\hfill$\square$\end{trivlist}}

\title{Efficient Manipulation Task Planning\\
   via Reuse-Informed Planning Cost Optimization}
\author{Christopher M. Dellin}
\date{\today}

\renewcommand{\maketitlehookd}{
\begin{center}
\vspace{0.7in}
The Robotics Institute\\
Carnegie Mellon University\\
Pittsburgh, PA 15213\\
\vspace{0.7in}
\textbf{Thesis Committee:}\\
Siddhartha Srinivasa, CMU RI (Chair)\\
Anthony Stentz, CMU RI\\
Maxim Likhachev, CMU RI\\
Lydia Kavraki, Rice University\\
%\vspace{0.7in}
%\emph{Submitted in partial fulfillment of the requirements\\
%for the degree of Doctor of Philosophy.}
\end{center}
}

\begin{document}

\maketitle

\begin{abstract}
Driven by a symbolic task planner, plan a feasible or low-cost sequence of
robot trajectory segments to solve a multi-step manipulation problem
(e.g. move an object, turn a valve, etc).

\textbf{From RSS paper:}
Motion planning approaches that build graphs
in the collision-free subset of configuration space
have proven promising
for high-dimensional articulated robotics problems
in unstructured environments.
However, many complex tasks (e.g. manipulation)
present two primary challenges.
First, the subset of collision-free configurations changes each time
the robot, objects, or people move, items are grasped or released,
or the fidelity of the robot's models changes.
This makes it difficult not only to apply the results of prior
planning computation to the current problem,
but also to efficiently consider planned or hypothesized motions,
especially in multi-step tasks.
Second, human-scale tasks are time-sensitive,
and these approaches incur significant planning cost
(comparable to execution cost)
which is dominated by collision checking.
To address these challenges,
we make two principal contributions.
First, we introduce \emph{multi-set planning},
a formulation which explicitly represents structure
between similar problems in C-space
using set-theoretic relations
and a cost model incorporating both planning and execution costs.
Second, we present the \emph{Multi-Set PRM} algorithm
which exploits this representation
by applying best-first search over roadmaps
with an objective which optimistically minimizes these costs.
We show that this approach automatically reuses planning computation
from similar problems when useful,
naturally replicating diverse behavior from prior
manipulation work designed to improve planner efficiency,
such as cached graphs, conservative bounding volumes,
and handling of dynamic environments.
We detail experimental results on a multi-step
manipulation task which show greater than a 3x improvement
in planning costs,
and provide an open-source implementation of our planner.
\end{abstract}

\tableofcontents


%\begin{figure}
%\begin{widepage}
%   \centering
%   \begin{subfigure}[b]{0.24\textwidth}
%      \begin{center}
%      \includegraphics[width=\textwidth]{figs/switchboard.jpg}
%      
%      \includegraphics[width=\textwidth]{figs/mech-switches.jpg}
%      \end{center}
%      \caption{Something}
%   \end{subfigure}
%   \begin{subfigure}[b]{0.24\textwidth}
%      \begin{center}
%      \includegraphics[width=\textwidth]{figs/assembly-line.jpg}
%      
%      \includegraphics[width=\textwidth]{figs/car-robots.jpg}
%      \end{center}
%      \caption{Something}
%   \end{subfigure}
%   \begin{subfigure}[b]{0.24\textwidth}
%      \begin{center}
%      \includegraphics[width=\textwidth]{figs/table-clearing.jpg}
%      
%      \includegraphics[height=2in]{figs/herb-fuze.jpg}
%      \end{center}
%      \caption{HERB Robot}
%   \end{subfigure}
%   \begin{subfigure}[b]{0.24\textwidth}
%      \begin{center}
%      \includegraphics[width=\textwidth]{figs/chernobyl.jpg}
%      
%      \includegraphics[height=2in]{figs/chimp-debris.jpg}
%      \end{center}
%      \caption{CHIMP Robot}
%   \end{subfigure}
%   \caption{Manipulation problems.}
%\end{widepage}
%\end{figure}


\newpage
\chapter{Introduction}

The steady advancement of technology
has automated an increasing variety of menial or dangerous tasks
previously performed by humans.
Computer algorithms now trade our stocks,
route our telephone calls and packages,
and fly our planes,
and simple machines clean our clothes and wash our dishes.

More complex tasks require complex robots with many
degrees of freedom.
Manipulation tasks, in particular,
present challenges in many areas including
perception, symbolic reasoning, and motion planning.
Successful applications have so far been largely
confined to large-scale manufacturing domains,
whose prescribed and structured environments
allow these challenges to be overcome.

However,
manipulation tasks such as clearing a kitchen table
or moving debris in a dangerous disaster scenario
can not yet be planned for quickly and reliably.
\begin{quote}
\emph{%
This thesis proposes an
efficient and robust motion planning approach
well-suited
to articulated robots
performing recurring manipulation tasks
in dynamic, unstructured environments.
}
\end{quote}

We outline the general structure of multi-step manipulation planning
in Chapter~\ref{chap:formulation}.
There are two principal challenges inherent in
human-scale manipulation tasks
that must be addressed by such approaches,
which we review here.

\textbf{Challenge 1: Task Efficiency.}

Autonomous systems performing manipulation tasks are
resource-constrained.
If a home robot takes thirty minutes to clear a table,
or a disaster response robot exhausts its battery ten minutes
into its mission,
these robots will not see widespread use.
These metrics are only meaningful
when applied across the entire task,
from the point it is assigned to the robot
to the point it is complete.

In order to accomplish such a manipulation task,
an autonomous robot must expend two types of effort.
First, it must allocate computation to \emph{plan}
a sequence of motions that will acheive the task.
Second, it must \emph{execute} these plans using its actuators.
Generally, there is a tradeoff between these two;
spending more effort during planning produces paths that are
cheaper to execute.
Planning costs are dominated by \emph{validity checking} --
e.g. checking whether configurations are free from collision.

Robots performing real-world human-scale manipulation tasks
tend to expend comparable effort in these two areas
(see Figure~\ref{fig:plan-exec-cost}).
While some approaches (e.g. anytime planning) attempt to capture
this tradeoff,
our approach,
the Greedy PRM (Chapter~\ref{chap:inflate}),
instead explicitly optimizes for both planning
and execution effort
given a planning effort model.
This allows the planner to determine the proper allocation of effort
between planning and execution in order to minimize total task cost.

Next, Chapter~\ref{chap:graphs-in-continuous}
discusses how to embed these roadmaps efficiently
into continuous configuration spaces,
touching on completeness,
efficiency, etc.

{
\setlength{\offsetpage}{0.5in}
\begin{figure}
\begin{widepage}
\begin{center}
   \begin{subfigure}[b]{1.4in}
      \begin{center}
      \includegraphics{build/intro-cost-herb}
      \end{center}
      \caption{\textsc{Herb} Home Robot}
   \end{subfigure}%
   \quad%
   \begin{subfigure}[b]{2.0in}
      \begin{center}
      \includegraphics{build/intro-cost-chimp}
      \end{center}
      \caption{\textsc{Chimp} Disaster Response Robot}
   \end{subfigure}%
   \quad%
   \begin{subfigure}[b]{2.0in}
      \begin{center}
      \includegraphics{build/intro-cost-axis}
      \end{center}
      \caption{Planning vs. Execution Cost}
   \end{subfigure}
   \caption{For manipulation tasks,
      both the \textsc{Herb} \cite{srinivasa2012herb20}
      and \textsc{Chimp} \cite{stentz2014chimp} robots
      incur comparable cost (e.g. time or energy)
      during planning and execution.
      Our approach considers both explicitly.}
   \label{fig:plan-exec-cost}
\end{center}
\end{widepage}
\end{figure}
}

\textbf{Challenge 2: Sub-Problem Structure.}

While planning cost is a significant component
in resource-constrained human-scale problems,
manipulation tasks exhibit a structure
which makes it difficult to apply fast planning approaches.
In particular,
they are inherently composed of multiple distinct sub-problems,
each of which 
must be validated a different subset of configuration space.
For example, see the manipulation task in
Figure~\ref{fig:intro-multi-step}.

We could do na\"{\i}ve planning, like in the
DRC Trials \cite{dellin2014drc},
with no reuse.
We call a single-query planner for each step.
Either we generate roots at the start,
or we let each sub-planner pick a root it can get to, and commit.
First, we can get stuck,
comitting to something that either is infeasible, or takes too long.
Second, this is too slow --
each sub-plan simply takes too long.

We could try multi-query planning,
but as mentioned,
the valid subset changes for each step.

We solve this in two ways.
First, in Chapter~\ref{chap:multi-set},
we introduce the multi-set planning problem.
We show that while the valid subsets are different for each step,
they are related in a structured way.
In fact, we show how lots of different prior ideas for planner
efficiency are unified by this formalism.

Second, Chapter~\ref{chap:multi-set-prm}
uses the multi-set formalism as a planning cost model
for use by the Greedy PRM.
The resulting algorithm,
the Multi-Set PRM,
uses propositional logic to represent multi-set stuff
algorithmically.
We show how we can incremental graph search approaches
to make it super fast.

{
\setlength{\offsetpage}{0.75in}
\begin{figure}
\begin{widepage}
\begin{center}

\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-a.png}
\caption{Start config}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-b.png}
\caption{Step 1 in $X_1$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-c.png}
\caption{Step 2 in $X_2$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-d.png}
\caption{Step 3 in $X_3$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-e.png}
\caption{End config}
\end{subfigure}

\vspace{0.1in}

   \begin{subfigure}[b]{4.0in}
      \begin{center}
      \includegraphics{build/intro-subprob-cspace}
      \end{center}
      \caption{Plan sequences
         within distinct free $\mathcal{C}$-subsets
         from the problem above.}
   \end{subfigure}%
   \quad%
   \begin{subfigure}[b]{2.0in}
      \begin{center}
      \includegraphics{build/intro-subprob-axis}
      \end{center}
      \caption{Single vs. Multi Query Planners}
   \end{subfigure}
   \caption{\textsc{Herb} plans for a simple manipulation task
      to grasp, transfer, and drop a mug from a table into a bin
      before returning to an end configuration.
      Each sub-problem requires a path in a distinct free subset of
      configuration space;
      our approach enables partial reuse between these steps.}
   \label{fig:intro-multi-step}
\end{center}
\end{widepage}
\end{figure}
}

\textbf{Applications and Experiments}

We give a bunch of examples of this framework
for different robots.
For example, I really want to talk about robots idly
hypothesizing worlds.

{
\setlength{\offsetpage}{0.75in}
\begin{figure}
\begin{widepage}
\begin{center}
\begin{tikzpicture}

% axes
\draw[->,thick] (0,0) -- (0,8); 
\draw[->,thick] (0,0) -- (12,0);
\node[rotate=90,align=center] at (-1.0,4)
   {Challenge 1:\\Task Efficiency};
\node[align=center] at (6,-1.6)
   {Challenge 2:\\Sub-Problem Structure};

% y tics
\draw (-0.2,1) -- (0.2,1);
\node[rotate=90,align=center] at (-0.64,1)
   {considers\\[-0.04in]execution cost};
\draw (-0.2,7) -- (0.2,7);
\node[rotate=90,align=center] at (-0.8,7)
   {considers\\[-0.04in]planning and\\[-0.04in]execution cost};

% x tics
\draw (2,-0.2) -- (2,0.2);
\node[align=center] at (2,-0.5) {no reuse};
\draw (6,-0.2) -- (6,0.2);
\node[align=center] at (6,-0.5) {two-set reuse};
\draw (10,-0.2) -- (10,0.2);
\node[align=center] at (10,-0.5) {full reuse};

% algorithms
\node[draw,ellipse,align=center] at (2,1)
   {Lazy PRM \cite{bohlin2000lazyprm}};

\node[draw,ellipse,align=center] at (6,1)
   {\cite{leven2000changing}, \cite{kallman2004dynamicroadmaps},
   \cite{jaillet2004dynamicprm}};

\node[draw,ellipse,align=center] at (2,7)
   {Greedy PRM\\(Chapter~\ref{chap:inflate})};

\node[draw,ellipse,align=center] at (10,7)
   {Multi-Set PRM\\(Chapter~\ref{chap:multi-set-prm})};

\end{tikzpicture}
\caption{Graphical outline of $\mathcal{C}$-space planners.
   Work in progress.}
\label{fig:graphical-outline}
\end{center}
\end{widepage}
\end{figure}
}



\newpage
\chapter{Sub-Problems in Manipulation Planning}
\label{chap:formulation}

In this chapter,
we lay out the structure of the manipulation planning problem.

Definitely reference DRC Trials paper for planning vs. execution
time breakdown!

\section{Sub-Problem Structure}

{
\setlength{\offsetpage}{0.5in}
\begin{figure}
\begin{widepage}
\begin{center}

\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-a.png}
\caption{Start config}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-b.png}
\caption{Step 1 in $X_1$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-c.png}
\caption{Step 2 in $X_2$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-d.png}
\caption{Step 3 in $X_3$}
\end{subfigure}
\begin{subfigure}[t]{0.19\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-e.png}
\caption{End config}
\end{subfigure}

\vspace{0.3cm}

\begin{subfigure}[t]{\linewidth}
\begin{center}
\begin{tikzpicture}
\tikzset{>=latex} % arrow heads

% top: symbolic planner
\node[draw,ellipse,align=center] (high) at (0,0)
   {Task Planner:\\Clear the table};
\node[draw,circle,align=center,inner sep=0,minimum size=1.9cm]
   (step1) at (-4.2,-2)
   {Step 1:\\Transit to\\[-0.04in]grasp};
\node (grasp) at (-2.1,-2) {Grasp};
\node[draw,circle,align=center,inner sep=0,minimum size=1.9cm]
   (step2) at (0,-2)
   {Step 2:\\Transfer to\\[-0.04in]drop};
\node (drop) at (2.1,-2) {Drop};
\node[draw,circle,align=center,inner sep=0,minimum size=1.9cm]
   (step3) at (4.2,-2)
   {Step 3:\\Transit to\\[-0.04in]home};
\draw[->] (high) -- (step1);
\draw[->] (high) -- (step2);
\draw[->] (high) -- (step3);
\draw[->] (step1) -- (grasp);
\draw[->] (grasp) -- (step2);
\draw[->] (step2) -- (drop);
\draw[->] (drop) -- (step3);

% middle: c-space sequence
% valid subsets
\node[draw,black,rounded corners,
   minimum height=2.3cm,minimum width=4.5cm]
   (X1) at (-3.5,-4.75) {};
\node[draw,black,rounded corners,
   minimum height=2.6cm,minimum width=5.5cm]
   (X2) at (0,-4.75) {};
\node[draw,black,rounded corners,
   minimum height=2.3cm,minimum width=5.5cm]
   (X3) at ( 4,-4.75) {};
% root sets
\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   (Xgrasp) at (-2,-4.75) {};
\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   (Xdrop) at (2,-4.75) {};
\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   (Xend) at (6,-4.75) {};
% set labels
\node[above=-0.6cm of Xgrasp] {$X_{\mbox{\scriptsize grasp}}$};
\node[above=-0.6cm of Xdrop] {$X_{\mbox{\scriptsize drop}}$};
\node[above=-0.6cm of Xend] {$X_{\mbox{\scriptsize end}}$};
\node[above left=-0.6cm and -2.1cm of X1] {$X_1$};
\node[above=-0.75cm of X2] {$X_2$};
\node[above=-0.6cm of X3] {$X_3$};
% nodes and paths
\node[circle,fill=black,inner sep=2] (xstart) at (-5,-4.9) {};
\node[circle,fill=black!50,inner sep=2] (xg1) at (-1.9,-4.6) {};
\node[circle,fill=black,inner sep=2] (xg2) at (-2.1,-5.3) {};
\node[circle,fill=black,inner sep=2] (xd1) at ( 1.9,-4.5) {};
\node[circle,fill=black!50,inner sep=2] (xd2) at ( 2.1,-5.0) {};
\node[circle,fill=black!50,inner sep=2] (xd3) at ( 2.0,-5.4) {};
\node[circle,fill=black!50,inner sep=2] (xe1) at ( 6.1,-4.7) {};
\node[circle,fill=black,inner sep=2] (xe2) at ( 5.9,-5.2) {};
\node[above=0cm of xstart] {$x_{\mbox{\scriptsize start}}$};
% lines
\draw[line width=1.5mm,white]
   (xstart) -- (xg1) (xg1) -- (xd1) (xg1) -- (xd2) (xg1) -- (xd3)
   (xg2) -- (xd2) (xg2) -- (xd3) (xd1) -- (xe1) (xd2) -- (xe1)
   (xd2) -- (xe2) (xd3) -- (xe1) (xd3) -- (xe2);
\draw[draw=black!50]
   (xstart) -- (xg1) (xg1) -- (xd1) (xg1) -- (xd2) (xg1) -- (xd3)
   (xg2) -- (xd2) (xg2) -- (xd3) (xd1) -- (xe1) (xd2) -- (xe1)
   (xd2) -- (xe2) (xd3) -- (xe1) (xd3) -- (xe2);
\draw[line width=1.5mm,white]
   (xstart) -- (xg2) (xg2) -- (xd1) (xd1) -- (xe2);
\draw
   (xstart) -- (xg2) (xg2) -- (xd1) (xd1) -- (xe2);
% grey sets (overlay)
\node[fill=black,opacity=0.1,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   at (-2,-4.75) {};
\node[fill=black,opacity=0.1,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   at (2,-4.75) {};
\node[fill=black,opacity=0.1,rounded corners,
   minimum height=2cm,minimum width=1.2cm]
   at (6,-4.75) {};
% question mark bubbles
\node[circle,fill=white,fill opacity=0.9,inner sep=7pt]
   at (-3.75,-4.9) {\LARGE ?};
\node[circle,fill=white,fill opacity=0.9,inner sep=7pt]
   at (0,-4.9) {\LARGE ?};
\node[circle,fill=white,fill opacity=0.9,inner sep=7pt]
   at (4.0,-4.9) {\LARGE ?};

% bottom: individual planner instances
\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=3.5cm]
   (sm1) at (-4.2,-7.75) {};
\node[draw,black,fill=black!10,rounded corners,
   minimum height=1.7cm,minimum width=0.8cm,
   right=-1cm of sm1] {};
\node[circle,fill=black!50,inner sep=2] (sm1xstart) at (-5.4,-7.75) {};
\node[circle,fill=black!50,inner sep=2] (sm1xg1) at (-2.9,-7.5) {};
\node[circle,fill=black!50,inner sep=2] (sm1xg2) at (-3.1,-8.1) {};
\draw[draw=black!50]
   (sm1xstart) -- (sm1xg1) (sm1xstart) -- (sm1xg2);
\node[above=-0.5cm of sm1] {\footnotesize $X_1$};
\node[circle,fill=white,fill opacity=0.9,inner sep=5pt]
   at (-4.2,-7.85) {\Large ?};

\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=3.5cm]
   (sm2) at (0.5,-7.75) {};
\node[draw,black,fill=black!10,rounded corners,
   minimum height=1.7cm,minimum width=0.8cm,
   left=-1cm of sm2] {};
\node[draw,black,fill=black!10,rounded corners,
   minimum height=1.7cm,minimum width=0.8cm,
   right=-1cm of sm2] {};
\node[circle,fill=black!50,inner sep=2] (sm2xg1) at (-0.6,-7.5) {};
\node[circle,fill=black!50,inner sep=2] (sm2xg2) at (-0.8,-8.1) {};
\node[circle,fill=black!50,inner sep=2] (sm2xd1) at ( 1.6,-7.4) {};
\node[circle,fill=black!50,inner sep=2] (sm2xd2) at ( 1.8,-7.9) {};
\node[circle,fill=black!50,inner sep=2] (sm2xd3) at ( 1.7,-8.3) {};
\draw[draw=black!50]
   (sm2xg1) -- (sm2xd1) (sm2xg1) -- (sm2xd2) (sm2xg1) -- (sm2xd3)
   (sm2xg2) -- (sm2xd1) (sm2xg2) -- (sm2xd2) (sm2xg2) -- (sm2xd3);
\node[above=-0.5cm of sm2] {\footnotesize $X_2$};
\node[circle,fill=white,fill opacity=0.9,inner sep=5pt]
   at (0.5,-7.85) {\Large ?};

\node[draw,black,rounded corners,
   minimum height=2cm,minimum width=3.5cm]
   (sm3) at (5.2,-7.75) {};
\node[draw,black,fill=black!10,rounded corners,
   minimum height=1.7cm,minimum width=0.8cm,
   left=-1cm of sm3] {};
\node[draw,black,fill=black!10,rounded corners,
   minimum height=1.7cm,minimum width=0.8cm,
   right=-1cm of sm3] {};
\node[circle,fill=black!50,inner sep=2] (sm3xd1) at ( 4.0,-7.4) {};
\node[circle,fill=black!50,inner sep=2] (sm3xd2) at ( 4.2,-7.9) {};
\node[circle,fill=black!50,inner sep=2] (sm3xd3) at ( 4.1,-8.3) {};
\node[circle,fill=black!50,inner sep=2] (sm3xe1) at ( 6.4,-7.6) {};
\node[circle,fill=black!50,inner sep=2] (sm3xe2) at ( 6.2,-8.1) {};
\draw[draw=black!50]
   (sm3xd1) -- (sm3xe1) (sm3xd1) -- (sm3xe2) (sm3xd2) -- (sm3xe1)
   (sm3xd2) -- (sm3xe2) (sm3xd3) -- (sm3xe1) (sm3xd3) -- (sm3xe2);
\node[above=-0.5cm of sm3] {\footnotesize $X_3$};
\node[circle,fill=white,fill opacity=0.9,inner sep=5pt]
   at (5.2,-7.85) {\Large ?};

% arrows
\draw[->] (-4.1,-6.1) -- (-4.4,-6.6);
\draw[->] ( 0.3,-6.2) -- ( 0.4,-6.6);
\draw[->] ( 4.5,-6.1) -- ( 4.8,-6.6);

% side labels
\node[draw,rotate=90,align=center] at (-6.7,-2)
   {Symbolic\\Plan};
\node[draw,rotate=90,align=center] at (-6.7,-4.75)
   {$\mathcal{C}$-space\\Planning};
\node[draw,rotate=90,align=center] at (-6.7,-7.75)
   {Individual\\Planner Queries};

\end{tikzpicture}
\end{center}
\caption{This thesis focuses on efficient geometric planning
   for manipulation tasks (the lower two levels here).
   Task planning can be performed by an autonomous
   symbolic planner,
   or guided by a human operator.}
\end{subfigure}

\end{center}
\caption{Diagram of multi-step planning framework.}
\label{fig:diagram-multi-step}
\end{widepage}
\end{figure}
}

The manipulation problem has a particular structure,
which we discuss here.
See Figure~\ref{fig:diagram-multi-step}
for a diagram.

Briefly discuss the higher-level planner.
Not doing research here -- just need something that specifies
geometric goals.
Complementary to symbolic planners
or from humans (e.g. the DRC -- need cite).
For this proposal,
will only discuss seqential sub-plans,
but an intelligent meta-planner
can do non-sequential stuff too.

\section{Motivation: DRC Trials}

Talk a lot about the DRC approach.
It was slow, and it got stuck!

Copy-paste in from the ISER paper!

\section{Approach}

Multi-step problem structure (lots of options at each step);
decomposition into a bunch of "local planner" like things.
We're essentially building a meta-graph.
Don't get stuck.

We talk a lot about the mapping
from continuous spaces to graphs in
Chapter~\ref{chap:graphs-in-continuous}.

Talk about subgoals in A* literature.

For now, assume a prescribed order,
but we'll talk later about more complex meta-planning
approaches.

\subsection{Root Sampling}

Do sampling at this higher level.
(Can't rely on the sub-planners to generate their own starts/goals --
they must be synchronized.)
Potential research question: learn good intermediate goals.

\subsection{Two Ways to Make it Fast}

The proposal is split into two complementary things,
guided by how slow collision checking is.

Chapters 3,4 focus WITHIN each step.
Make each step fast.

Chapters 5,6 focus BETWEEN steps.
Exploit structure between steps (Chapter~\ref{chap:multi-set}).
Single-query vs. multi-query.

\section{Related Work}

While we will primarily apply graph search techniques to this problem,
we start by reviewing alternative approaches.

\section{Review of Alternative Approaches}
\label{sec:related-work}

Since $C$ is continuous,
all approaches must introduce some sort of discretization
in order to compute solutions.
We choose to build a graph consisting of vertices and edges in $C$,
and then search that graph (Section~\ref{sec:best-first}).
We do this because we can rely on existing techniques,
and because an explicit graph can be more easily reused than other
approaches.
In this section, we discuss alternative approaches to solving
the motion planning problem for articulated robots.

%\subsection{Multi-Query Approaches}
%
%We could run a PRM \cite{kavrakietal1996prm}.
%Commit to a fixed graph,
%and determine the validity of each vertex and edge w.r.t.
%$\mathcal{C}_{\mbox{\scriptsize free}}$.
%Then, at query time,
%run A* to find the shortest path (this is fast due to graph sparseness).
%This is good because it reuses work.
%Unfortunately,
%(a) our $\mathcal{C}_{\mbox{\scriptsize free}}$
%is different for every subplan
%(and for different options with each),
%and (b) we don't want to determine validity over the entire graph
%because it's costly.

\subsection{Anytime algorithms}

Compare to RRT*, FMT*, BIT*, etc.

\subsection{Other}

Need to look into the SBL planner \cite{sanchezante2001sbl}
(Single Query BiDirectional Lazy PRM).

\subsection{Incremental Construction Algorithms}

We could construct the graph incrementally and in response to the shape
of $\mathcal{C}_{\mbox{\scriptsize free}}$.
RRTs behave well for quickly finding feasible paths.
We'll compare against them at the end of this chapter.
Also talk about ESTs.
Difficult to cache things.

\subsection{Trajectory Optimization}

One approach is trajectory optimization.
For example, there's CHOMP \cite{zucker2013chomp}
and TrajOpt \cite{schulman2013trajopt}.
Lots of other prior work here that is not manipulation-focused.

Local minima problems.
Difficult to cache / apply to similar problems.

This is largely complementary.
Use sampling-based planning to quickly find feasible solutions,
and then optimize them.

\section{Other Stuff}

Other stuff to touch on:
\begin{itemize}
\item Dealing with constraints
\item Dealing with dual-arm stuff
\item Dealing with optimizers (run afterwards!)
   Most solution paths will be unexecuted, so optimize later!
\end{itemize}


\newpage
\chapter{Quickly Searching Explicit Expensive Graphs}
\label{chap:inflate}

In order for an articulated robot to perform manipulation tasks
in changing, unstructured environments,
it must be able to quickly solve motion planning queries in its
configuration space.
While there are many types of approaches for such queries
which we discuss in Section~\ref{sec:related-work},
one of the most common are graph search algorithms.
In this chapter,
we discuss the efficiency tradeoffs induced by formulating
the articulated motion planning problem as best-first search,
propose a general planning framework which accounts for these tradeoffs,
and examine some empirical results.

\paragraph{Two Notions of Efficiency.}

Throughout this chapter,
we reference two different types of efficiency
with regard to robotic tasks.
First, once a planner has computed a solution path or trajectory,
there is the cost incurred while executing that trajectory.
This is the traditional cost optimized for by planners.
Second, there is the cost incurred from actually computing the solution
itself.

This dichotomy of effort is, of course, not new.
From Winston's \emph{Articifial Intelligence} \cite{winston1977ai},
\begin{quote}
   ``Properly speaking, the problem of determining a good path is a search
   problem in which two kinds of effort are involved:
   \begin{itemize}
   \item First, there is the effort expended in \emph{finding} either
      some path or the best path.
   \item And, second, there is the effor actually expended in
      \emph{traversing} the network.''
   \end{itemize}
\end{quote}

For the application of manipulation planning for articulated robots,
in paricular,
the costs associated with these two components tend to be of comparable
magnitude.
For example,
when time is used as an efficency metric,
both planning and execution times for household applications
tend to be on the order of 1-2 seconds.
Alternatively, given
modern computational and actuator technologies for human-scale problems,
both planning and execution tend to consume similar amounts of energy.
Therefore,
the manipulation problem demands that
(a) the cost of plans and
(b) the cost of planning both be considered.

\paragraph{General Problem Characterization.}

We are motivated to solve motion planning problems for articulated robots.
In the simplest version of this problem,
the robot has a continuous configuration space $C$,
with some subset $C_{obs}$ in collision.
All feasible trajectories must then lie entirely in
$\mathcal{C}_{\mbox{\scriptsize free}} = C \setminus C_{obs}$.
In general, testing some configuration $q$ for membership in
$\mathcal{C}_{\mbox{\scriptsize free}}$
is an expensive operation.
A typical query asks for a trajectory $t: [0,1] \rightarrow Q$ between
a start set and a goal set (e.g. $t(0) \in Q_s$ and $t(1) \in Q_g$.
We defer discussion constraints until later.
We are focused on configuration spaces without dynamics.

In this chapter,
we'll primarly focus on single-query things,
but we'll keep in mind that we want things that can enable reuse eventually.

\section{Best-First Graph Search}
\label{sec:best-first}

In this section,
we discuss general best-first search over explicit graphs.

\subsection{Formulating Motion Planning as Graph Search}

Continuous space, graph over it.
We have a graph $G$ with vertices $V$ and edges $E$.
We have some start set $V_s$ and some goal set $V_g$.
We represent a path through the graph as
$\pi = \{ v_0, v_1, v_2, \dots, v_n \}$;
a candidate solution path then has $v_0 \in V_s$ and $v_n \in V_g$.
We assume that only edges have costs,
such that the cost of a path is the cost if its constituent edges.
The cost of an edge is given by $c(v_a,v_b)$, and is always non-negative.
We assume that the graph is endowed with an admissible heuristic edge cost
function
$\hat{c}(v_a,v_b)$
which is inexpensive to compute.

We observe that such graphs motion planning for articulated robots
exhibit several properties that influence solution techniques.

\textbf{Sparsity.}
The size of a graph necessary to solve common problems
is relatively small.
In particular, it is reasonable to store the entire graph explicitly in
memory;
techniques to incrementally build the graph
are not necessary.
Also,
we are not restricted to only expanding successors of a vertex;
we can simply make queries of the graph.
\cdnote{``Sparsity'' is not a good word here, since it already has meaning
for graphs.}

\textbf{Expensive Edge Evaluations.}
Evaluating edge costs (e.g. testing for membership in
$\mathcal{C}_{\mbox{\scriptsize free}}$)
is expensive.

See Figure~\ref{fig:seg-intro} for an example.

\begin{figure}
\centering
\begin{tikzpicture}
\tikzstyle{vertex}=[circle,draw=black,inner sep=0pt,minimum size=5pt]

\node[vertex] (a) at (0,0) {};
\node[vertex] (b) at (2,0) {};
\node[vertex] (c) at (2.5,1) {};
\node[vertex] (d) at (1,1) {};
\node[vertex] (e) at (3,-0.5) {};
\node[vertex] (f) at (4,0.5) {};
\node[vertex] (g) at (4.5,-0.5) {};
\node[vertex] (h) at (1.5,-1) {};

\draw[black,->,>=latex] (a) -- (b) node [midway, fill=white] {5};
\draw[black,->,>=latex] (a) -- (h) node [midway, fill=white] {4};
\draw[black,->,>=latex] (a) -- (d) node [midway, fill=white] {3};
\draw[black,->,dashed,>=latex] (b) -- (c);
\draw[black,->,dashed,>=latex] (d) -- (c);
\draw[black,->,dashed,>=latex] (c) -- (e);
\draw[black,->,dashed,>=latex] (c) -- (f);
\draw[black,->,dashed,>=latex] (f) -- (g);
\draw[black,->,dashed,>=latex] (e) -- (g);
\draw[black,->,dashed,>=latex] (h) -- (e);

\draw[black,->,>=latex] (6,0.2) -- (7,0.2);
\node[anchor=west] at (7,0.2) {evaluated edge};
\draw[black,->,dashed,>=latex] (6,-0.2) -- (7,-0.2);
\node[anchor=west] at (7,-0.2) {unevaluated edge};

\node[left=0pt of a] {$v_s$};
\node[right=0pt of g] {$v_g$};

\end{tikzpicture}
\caption{A small explicit graph with some evaluated edges.}
\label{fig:seg-intro}
\end{figure}

\subsection{Generic Best-First Search Algorithm over Paths}

Best-first search \cite{winston1977ai}
is a general class of search algorithms.
We choose to express the general algorith
over \emph{paths} instead of \emph{vertices}
for clarity and generality
because we are focused primarily on explicit graphs.
However, Section~\ref{sec:implicit} shows
how it reduces to traditional A* search
for certain types of evaluation functions,
as is required when searching over implicit graphs.

\begin{algorithm}
\caption{Generic Best-First Search Algorithm}
\label{alg:generic-best-first}
\begin{algorithmic}[1]
\Procedure {\textsc{GenericBestFirst}}{$G$}
\Loop
   \State $\pi^* = \arg \min\limits_{\Pi} f(\pi)$
      \Comment{For some path cost function $f(\pi)$}
      \label{line:generic-select-optimistic-path}
   \If {$\pi^*$ fully evaluated}
      \State \Return $\pi^*$
   \EndIf
   \State \textsc{Evaluate}$(\pi^*)$
      \Comment{For some evaluate function}
\EndLoop
\EndProcedure
\end{algorithmic}
\end{algorithm}

Consider the general best-first search algorithm
(Algorithm~\ref{alg:generic-best-first}).
It maintains some sort of data structure storing known data about the
graph (e.g. tags on vertices or edges).
It simply iterates over optimistically-optimal ``best'' paths,
partially evaluating each.
(Note especially the greedy nature of this search.)
See Figure~\ref{fig:seg-edge-example} for a simple example.

\begin{figure}
\centering
\begin{subfigure}[b]{0.45\textwidth}
\begin{tikzpicture}
\tikzstyle{vertex}=[circle,draw=black,fill=white,inner sep=0pt,minimum size=5pt]

\coordinate (a) at (0,0);
\coordinate (b) at (2,0);
\coordinate (c) at (2.5,1);
\coordinate (d) at (1,1);
\coordinate (e) at (3,-0.5);
\coordinate (f) at (4,0.5);
\coordinate (g) at (4.5,-0.5);
\coordinate (h) at (1.5,-1);

\draw[black!10,line width=5pt,line cap=round] (a) -- (d) -- (c) -- (f) -- (g);

\node[vertex] (na) at (a) {};
\node[vertex] (nb) at (b) {};
\node[vertex] (nc) at (c) {};
\node[vertex] (nd) at (d) {};
\node[vertex] (ne) at (e) {};
\node[vertex] (nf) at (f) {};
\node[vertex] (ng) at (g) {};
\node[vertex] (nh) at (h) {};

\draw[black,->,>=latex] (na) -- (nb) node [circle,inner sep=2pt,midway,fill=white] {5};
\draw[black,->,>=latex] (na) -- (nh) node [circle,inner sep=2pt,midway,fill=white] {4};
\draw[black,->,>=latex] (na) -- (nd) node [circle,inner sep=2pt,midway,fill=white] {3};
\draw[black,->,dashed,>=latex] (nd) -- (nb);
\draw[black,->,dashed,>=latex] (nb) -- (nc);
\draw[black,->,dashed,>=latex] (nd) -- (nc) node [circle,inner sep=2pt,midway,fill=white] {2?};
\draw[black,->,dashed,>=latex] (nc) -- (ne);
\draw[black,->,dashed,>=latex] (nc) -- (nf) node [circle,inner sep=2pt,midway,fill=white] {4?};
\draw[black,->,dashed,>=latex] (nf) -- (ng) node [circle,inner sep=2pt,midway,fill=white] {3?};
\draw[black,->,dashed,>=latex] (ne) -- (ng);
\draw[black,->,dashed,>=latex] (nh) -- (ne);

\node[left=0pt of a] {$v_s$};
\node[right=0pt of g] {$v_g$};

\end{tikzpicture}
\caption{Select optimistic best path}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.45\textwidth}
\begin{tikzpicture}
\tikzstyle{vertex}=[circle,draw=black,fill=white,inner sep=0pt,minimum size=5pt]

\coordinate (a) at (0,0);
\coordinate (b) at (1.8,0);
\coordinate (c) at (2.3,1);
\coordinate (d) at (0.9,1);
\coordinate (e) at (2.7,-0.5);
\coordinate (f) at (3.6,0.5);
\coordinate (g) at (4.1,-0.5);
\coordinate (h) at (1.5,-1);

\draw[black!10,line width=5pt,line cap=round] (d) -- (c);

\node[vertex] (na) at (a) {};
\node[vertex] (nb) at (b) {};
\node[vertex] (nc) at (c) {};
\node[vertex] (nd) at (d) {};
\node[vertex] (ne) at (e) {};
\node[vertex] (nf) at (f) {};
\node[vertex] (ng) at (g) {};
\node[vertex] (nh) at (h) {};

\draw[black,->,>=latex] (na) -- (nb) node [circle,inner sep=2pt,midway,fill=white] {5};
\draw[black,->,>=latex] (na) -- (nh) node [circle,inner sep=2pt,midway,fill=white] {4};
\draw[black,->,>=latex] (na) -- (nd) node [circle,inner sep=2pt,midway,fill=white] {3};
\draw[black,->,dashed,>=latex] (nd) -- (nb);
\draw[black,->,dashed,>=latex] (nb) -- (nc);
\draw[black,->,>=latex] (nd) -- (nc) node [circle,inner sep=2pt,midway,fill=white] {3};
\draw[black,->,dashed,>=latex] (nc) -- (ne);
\draw[black,->,dashed,>=latex] (nc) -- (nf);
\draw[black,->,dashed,>=latex] (nf) -- (ng);
\draw[black,->,dashed,>=latex] (ne) -- (ng);
\draw[black,->,dashed,>=latex] (nh) -- (ne);

\node[left=0pt of a] {$v_s$};
\node[right=0pt of g] {$v_g$};

\end{tikzpicture}
\caption{Evaluate first unevaluated edge}
\end{subfigure}%
\caption{Generic best-first algorithm for an explicit graph,
   with $f(\pi)$ best known cost-from-start,
   and {\sc Eval} forward edge evaluations.
   This algorithm is guaranteed to terminate with a feasible path
   with mimimum path cost, if one exists.}
\label{fig:seg-edge-example}
\end{figure}

There are two choices:

\textbf{Cost Function $f(\pi)$.}
What is the cost function $f(\pi)$ over paths used to select the
path for evaluation at each iteration?
For now, we will use the following path objective:
\begin{equation}
   f_x(\pi) = \mbox{\emph{optimistic estimate of execution effort}}.
\end{equation}
In other worts, $f_x(\pi)$ gives a lower bound on the cost of executing
path $p$.
If the path consists of a mix of evaluated and unevaluated edges,
we could write this as:
\begin{equation}
   f_x(\pi) = \sum_{e \in \pi} \left\{
   \begin{array}{cl}
      c[e] & \mbox{if edge } e \mbox{ evaluated}  \\
      \hat{c}(e) & \mbox{otherwise} \\
   \end{array}
   \right.
   .
   \label{eqn:execution-cost-objective}
\end{equation}

\textbf{{\sc Evaluate} Procedure.}
How is a potential path evaluated?

The choice of these two components of the algorithm depend on what
functions are defined over the graph.
Likewise, the data structure is dependent on what is required
for the choices.

\subsection{Best-First Search on Implicit Graphs}
\label{sec:implicit}

Figure~\ref{fig:seg-edge-example} searches an explicit graph,
in which the entire graph structure is represented in memory.
Here, we briefly relate this path-oriented treatment of graph search
to well-known existing algorithms.

Often, due to resource constraints or convenience,
the graph is instead expressed \emph{implicitly}
with one or more operators which calculate the structure of the graph
in the local vicinity of a given vertex.
Initialized with one or more vertices (e.g. starts and/or goals),
an algorithm can incrementally ``discover'' more of the implicit
graph by repeatedly calling such function on discovered vertices.
As a result of this representation,
only a small portion of the graph might need to be explored
during the search.

Due to this implicit representation,
it is clear that each candidate path in $\Pi$ to be considered
(line \ref{line:generic-select-optimistic-path})
cannot generally exist of entirely known edges.
When enumerating candidate paths to the goal,
we must include potential ``virtual'' path segments
through the as-yet undiscovered portion of the graph
to approximate the path cost function $f(\pi)$.
The behavior of the search depends on this approximation,
as well as the nature of {\sc Evaluate} function induced by
the implicit representation operator(s) available.
Several variants are briefly discussed here.

\subsubsection{Relation to A*}

The most common implicit graph representation
is the \emph{expansion} or \emph{successor} function {\sc Successors}$(v)$
which yields all vertices reachable from the parent vertex $v$,
along with the associated edge costs.

Suppose, for now, that we only consider candidate paths that consist of:
(a) a first segment consisting over zero or more evaluated edges,
followed by
(b) an unexpanded ``frontier'' vertex $v_f$, followed by
(b) a second segment through the undiscovered portion of the graph.
We can then express $f_x(\pi)$ as:
\begin{equation}
   f_x(\pi)
   = \underbrace{f_{s \rightarrow v_f}(\pi)}_{g[v_f]}
   + \underbrace{f_{v_f \rightarrow g}(\pi)}_{h(v_f)}.
\end{equation}
These components correspond to the best-known cost-to-come $g[v_f]$
and the heuristic function $h(v_f)$ from A* search \cite{hart1968astar}.
See Figure~\ref{fig:seg-implicit} for an example with $h(v_f)=0$.

We can now produce a proof that as long as $h(v_f)$ is admissible,
and we are restricted to an {\sc Eval}$(\pi)$ function which 
expands the first unexpanded vertex,
the optimistic-optimal path $\pi^*$ at each iteration
follows the structure in the previous paragraph.
See Appendix~\ref{appendix:gs-proofs}.

\begin{figure}
\centering
\begin{subfigure}[b]{0.45\textwidth}
\begin{tikzpicture}
\tikzstyle{vertex}=[circle,draw=black,fill=white,inner sep=0pt,minimum size=5pt]

\coordinate (a) at (0,0);
\coordinate (b) at (2,0);
\coordinate (c) at (2.5,1);
\coordinate (d) at (1,1);
\coordinate (e) at (3,-0.5);
\coordinate (f) at (4,0.5);
\coordinate (g) at (4.5,-0.5);
\coordinate (h) at (1.5,-1);

\draw[black!10,line width=5pt,line cap=round] (a) -- (d);
\draw[black!10,line width=5pt,line cap=round,
   decorate,decoration=snake]
   (d) -- (g) node [black,circle,inner sep=2pt,midway,fill=white] {0?};

\node[vertex] (na) at (a) {};
\node[vertex] (nb) at (b) {};
%\node[vertex] (nc) at (c) {};
\node[vertex] (nd) at (d) {};
%\node[vertex] (ne) at (e) {};
%\node[vertex] (nf) at (f) {};
%\node[vertex] (ng) at (g) {};
\node[vertex] (nh) at (h) {};

\draw[black,->,>=latex] (na) -- (nb) node [circle,inner sep=2pt,midway,fill=white] {5};
\draw[black,->,>=latex] (na) -- (nh) node [circle,inner sep=2pt,midway,fill=white] {4};
\draw[black,->,>=latex] (na) -- (nd) node [circle,inner sep=2pt,midway,fill=white] {3};

\node[left=0pt of a] {$v_s$};
\node[right=0pt of g] {$v_g$};

\end{tikzpicture}
\caption{Select optimistic best path}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.45\textwidth}
\begin{tikzpicture}
\tikzstyle{vertex}=[circle,draw=black,fill=white,inner sep=0pt,minimum size=5pt]

\coordinate (a) at (0,0);
\coordinate (b) at (1.8,0);
\coordinate (c) at (2.3,1);
\coordinate (d) at (0.9,1);
\coordinate (e) at (2.7,-0.5);
\coordinate (f) at (3.6,0.5);
\coordinate (g) at (4.1,-0.5);
\coordinate (h) at (1.5,-1);

\draw[black!10,line width=5pt,line cap=round] (d) -- (c);
\draw[black!10,line width=5pt,line cap=round] (d) -- (b);

\node[vertex] (na) at (a) {};
\node[vertex] (nb) at (b) {};
\node[vertex] (nc) at (c) {};
\node[vertex] (nd) at (d) {};
%\node[vertex] (ne) at (e) {};
%\node[vertex] (nf) at (f) {};
%\node[vertex] (ng) at (g) {};
\node[vertex] (nh) at (h) {};

\draw[black,->,>=latex] (na) -- (nb) node [circle,inner sep=2pt,midway,fill=white] {5};
\draw[black,->,>=latex] (na) -- (nh) node [circle,inner sep=2pt,midway,fill=white] {4};
\draw[black,->,>=latex] (na) -- (nd) node [circle,inner sep=2pt,midway,fill=white] {3};
\draw[black,->,>=latex] (nd) -- (nb) node [circle,inner sep=2pt,midway,fill=white] {3};
\draw[black,->,>=latex] (nd) -- (nc) node [circle,inner sep=2pt,midway,fill=white] {3};

\node[left=0pt of a] {$v_s$};
\node[right=0pt of g] {$v_g$};

\end{tikzpicture}
\caption{Expand first unexpanded vertex}
\end{subfigure}%
\caption{Best-first algorithm for an implicit graph,
   with $f(\pi)$ best known cost-from-start,
   and {\sc Eval} forward vertex expansions.
   This is Dijkstra's algorithm \cite{dijkstra1959anote}.}
\label{fig:seg-implicit}
\end{figure}

Takeaway: A* uses a general heuristic function $h_g(v)$
because it doesn't have a representation of the full graph,
so it can't compute an actual best optimistic path.
I claim that for manipulation planning problems,
we can indeed reason over explicit graphs.

\subsubsection{Relation to BHFFA}

Let's say that we also have a function which computes the predecessors
of a vertex,
and also an admissible heuristic function $h(v_a,v_b)$ which computes
a lower-bound estimate of the optimal cost between two vertices.
Then the best-first thing to do is equivalent to the
Bidirectional Heuristic Front-to-Front Algorithm \cite{sint1977bhffa}.

\subsection{Best-First Search with Edge Evaluation}

What if, instead of operating over vertices (like A* and the like),
we operate over edges?
Figure~\ref{fig:seg-intro} illustrated the simplest such algorithm,
which selects the optimistic-optimal path,
and then evaluates the first as-yet unevaluated edge on the path.

I think that the forward-evaluation version of this is the same as
Optimal Generation A* (OPA*) and Simple Optimal Generation A* (SOGA*)
\cite{goldenberg2013epeastar},
which are modified versions of
Enhanced Partial Expansion A* \cite{felner2012epastar}.

\subsection{Bidirectional {\sc Eval} Procedures}

In general, over explicit graphs,
it usually makes sense to do bidirectional evaluations.
I need some data to back this up for my problem.
For example,
the Lazy PRM algorithm \cite{bohlin2000lazyprm}
is just best-first search
applied to binary edge cost functions
($c(e) \in \{ \hat{c}(e), \infty \}$)
with bidirectional edge evaluations
(although it actually uses a slightly fancier path evaluation function).

\section{Penalizing Planning Effort}

So far, we've been searching for a path which optimizes our solution
cost objective (\ref{eqn:execution-cost-objective}).
However, as we motivated in the introduction,
there are two distint notions of efficency,
and our objective so far (\ref{eqn:execution-cost-objective})
has only captured one of the two.
Here, we focus instead on \emph{planning efficiency},
and attempt to define an objective which captures it.
We hope that doing so will lead to searches which consume less 
time or energy.

\begin{equation}
   f_p(\pi) = \mbox{\emph{optimistic estimate of planning effort}}.
\end{equation}

What type of metric should we use?

\subsection{Metrics for Planning Effort}

For problems over very large graphs,
planning effort may be dominated by expanding vertices
or maintaining priority queues.
Therefore, traditional metrics for evaluating planning
effort are \emph{vertices expanded}
and \emph{heap percolates}.
However, for many manipulation problems,
search time is instead dominated by edge evaluations.

Therefore, we introduce a new objective $f_p$
which penalizes remaining effort required to evaluate edges
along a potential path:
\begin{equation}
   f_p(\pi) = \sum_{e \in \pi} \left\{
   \begin{array}{cl}
      0 & \mbox{if edge } e \mbox{ evaluated}  \\
      \hat{p}(e) & \mbox{otherwise} \\
   \end{array}
   \right.
   .
\end{equation}
This uses a new heuristic $\hat{p}(e)$ which estimates the cost
associated with evaluating an edge.
This could be planning time, computational energy required, etc.

The first graph planner to explicitly include such a heuristic
to estimate the remaining
computational planning effort in a best-first search
was A$_\epsilon^*$ \cite{pearl1982semiadmissible}.
While the approach we take is different from that of
\cite{pearl1982semiadmissible},
a motivating quote from this paper is relevant:
\begin{quote}
``The heuristic [\,$\hat{c}$\,] ... is of an entirely
different nature than the ... heuristic [\,$\hat{p}$\,] ... .
The former anticipates the reduction in \emph{solution quality} due to the
remaining part of the solution once it is found;
the latter estimates the \emph{computational effort}
required for completing the search.''
\end{quote}

Sidenote: RRT-Connect is sort of explicitly doing this
(optimizing at each step only for planning time,
but constrained to pass through the sampled point).

\subsection{General Weighted Objective}

In general, we might consider weighting each objective:
\begin{equation}
   f(\pi) = \lambda f_p(\pi) + (1 - \lambda) f_x(\pi) .
   \label{eqn:general-objective}
\end{equation}
Note that with $\lambda=0$,
we recover our old solution cost objective $f_x(\pi)$.
Note that this objective is used in an optimistic, greedy fashion at each
iteration of best-first search.

This is the objective used by the Greedy PRM,
described in Section~\ref{sec:greedy-prm}.

When expanded,
this can then be written:
\begin{equation}
   f(\pi) = \sum_{e \in \pi} \left\{
   \begin{array}{cl}
      (1 - \lambda) c[e] & \mbox{if edge } e \mbox{ evaluated}  \\
      \lambda \hat{p}(e) + (1 - \lambda) \hat{c}(e) & \mbox{otherwise} \\
   \end{array}
   \right.
   .
   \label{eqn:general-objective-explicit}
\end{equation}

\subsection{Simplification with Propotional Heuristics}

Suppose that our edge evaluation cost heuristic
were proportional to our edge execution cost heuristic,
\begin{equation}
   \hat{p}(e) = \alpha \, \hat{c}(e) .
\end{equation}
This might happen if, for example, each were proportional to the edge's
\emph{distance} (with longer paths taking longer to both collision check
and execute at constant velocity).
In this case, we can write:
\begin{equation}
   f(\pi) = (1-\lambda) \sum_{e \in \pi} \left\{
   \begin{array}{cl}
      c[e] & \mbox{if edge } e \mbox{ evaluated}  \\
      \left[ 1 + \frac{\alpha\lambda}{1 - \lambda} \right] \hat{c}(e) & \mbox{otherwise} \\
   \end{array}
   \right.
   .
   \label{eqn:prop-heuristics}
\end{equation}

\subsection{Equivalence to Weighted A*}

Consider the case where we're using forward vertex or edge evaluations
(as is required with implicit graph representations),
and $\lambda < 1$.
In this case, we can rewrite (\ref{eqn:prop-heuristics})
simply as:
\begin{equation}
   f(\pi) \propto
   \underbrace{\sum_{e \; \mbox{\scriptsize evaled}} c[e]}_{g[v_f]}
   +
   \underbrace{\left[ 1 + \frac{\alpha \lambda}{1-\lambda} \right]}_{
      \mbox{\scriptsize inflation factor } \epsilon}
   \underbrace{\hat{c}(e_{last})}_{h(v_f)}
   .
\end{equation}

In other words,
\emph{weighted A* is simply best-first search whose objective
   includes a planning effort term.}

In particular, if planning effort is proportional to execution
effort by a factor of $\alpha$,
a weighted A* search with inflation factor $\epsilon$
is the result of best-first search with
$\lambda = \frac{\epsilon-1}{\alpha+\epsilon-1}$.

\subsection{Relation to Experience Graphs}
\label{sec:egraphs}

Experience graphs \cite{phillips2012egraphs}
are a type of best-first search which
are designed to find paths quickly by incentivizing the planner
to rely on on edges from previous successful plans.

While the E-graph planner is originally expressed over implicit graphs,
we can instead express it as best-first search over paths
with the following objective:
\begin{equation}
   f_{\mbox{\scriptsize E-graphs}}(\pi) \propto \sum_{e \in \pi} \left\{
   \begin{array}{cl}
      c[e] & \mbox{if edge } e \mbox{ evaluated, this search} \\
      \epsilon \, c[e] & \mbox{if edge } e \mbox{ evaluated, previous search} \\
     \epsilon \, \epsilon^E \, \hat{c}(e) & \mbox{otherwise} \\
   \end{array}
   \right.
\end{equation}

The Greedy PRM applied to a single
$\mathcal{C}_{\mbox{\scriptsize free}}$ as described in this chapter
is equivalent to the E-Graph planner
with $\epsilon=1$ and $\epsilon^E = 1 + \frac{\alpha \lambda}{1-\lambda}$.
It's not immediately clear to me why one would choose $\epsilon \neq 1$.
(Note: we don't do shortcuts or snap motions.)

\section{Planner: Greedy PRM}
\label{sec:greedy-prm}

\cdnote{Actually, I think I should call this $\mbox{E}^8$,
   ``Estimating and Exploiting Ensemble Effort
   on Explicit graphs with Expensive Edge Evaluations''}

The Greedy PRM is the result of applying
best-first search with the $\lambda$-mediated objective
(\ref{eqn:general-objective})
to a simple single-$\mathcal{C}_{\mbox{\scriptsize free}}$ problem
in batches of $N$ samples.
Based on empirical results, we also use the bidirectional edge evaluation
algorithn,
since it tends to finish faster.

The Greedy PRM is the result of applying
best-first graph search to
a probabilistic roadmap \cite{kavrakietal1996prm}
embedded in $\mathcal{C}$,
where the cost of each edge captures an optimistic estimate of
the execution cost and the current planning cost remaining.
The planner effectively exploits the multi-set structure
from Section~\ref{subsec:problem-definition},
guided by the cost model from Section~\ref{subsec:cost-model}
to minimize total task cost.

The Greedy PRM is \emph{multi-query},
in that the same graph
structure $G$ is maintained within the configuration space
$\mathcal{C}$.

The algorithm is also \emph{lazy},
in that edge evaluations are deferred until they are needed.
In fact, it can be seen as a generalization of the
LazyPRM \cite{bohlin2000lazyprm}
which also considers planning cost in its objective.
Further,
the algorithm is heuristic-focused,
and its behavior mimics that of an inflated heuristic planner
depending on the selection of the planning/execution cost
tradeoff parameter $\lambda$
as described in Section~\ref{subsec:alg-opt-path-cost}.

\subsection{Best-First Search over Paths on Explicit Graphs}
\label{subsec:alg-greedy-prm}

\begin{algorithm}
\caption{Greedy PRM}
\label{alg:greedy-prm}
\begin{algorithmic}[1]
\Procedure {\textsc{GreedyPRM}}{$G, \mathcal{Q}, N, \lambda$}
%\State $G.V \leftarrow \emptyset$
%\State $G.E \leftarrow \emptyset$
\Loop
   \State \textsc{PrmAddSamples}($G, \mathcal{Q}, N$)
      \Comment See Sec.~\ref{subsec:alg-greedy-prm}
   \Loop
         \label{line:best-first-start}
      \State $\pi^* = \argmin\limits_{\pi \in \Pi(G,\mathcal{Q})}
         \big[ \lambda \, f_p[\pi] + (1 - \lambda) \, f_e[\pi] \big]$
         \label{line:e8-select-optimistic-path}
      \If {$\pi^* = \mbox{\textbf{nil}}$}
        \State \textbf{break}
      \EndIf
      \If {\textsc{EvalPath}$(\pi^*)$}
         \State \Return $\pi^*$
            \Comment Success
      \EndIf
   \EndLoop
      \label{line:best-first-end}
\EndLoop
\EndProcedure
\end{algorithmic}
\end{algorithm}

The Greedy PRM (Alg.~\ref{alg:greedy-prm})
operates on an initially empty persistent roadmap graph $G$.
Each vertex represents a configuration $x \in \mathcal{C}$,
and each edge represents a path $x(t)$ planned by a local planner.
Similarly to the LazyPRM,
edges are not evaluated until necessary.

The algorithm proceeds in \emph{batches};
at the start of each batch,
the \textsc{PrmAddSamples} procedure adds
$N$ additional vertices to the graph sampled from $\mathcal{C}$
(including sampled start and goal configurations from $\mathcal{Q}$
if not yet present),
and edges are generated according to the PRM construction method.
The Multi-Set PRM does not commit to any particular such method
(e.g. r-disk, K-nearest-neighbors).

The remainder of the algorithm
(lines \ref{line:best-first-start} - \ref{line:best-first-end})
proceeds as a best-first search over paths.
At each iteration,
we select the potentially feasible path $\pi^*$
which minimizes the optimistic
planning/execution cost function.
If no such path exists
(all paths have been shown to be infeasible),
we introduce a new batch.
Otherwise, we evaluate the current path with
\textsc{EvalPath}
(Section~\ref{subsec:alg-path-evaluation}),
returning the path on success.

Note that while
algorithm~\ref{alg:greedy-prm} supposes that you completely solve
one query before moving on to the next,
the planner can be interrupted at any point,
allowing for interleaving queries.

Line~\ref{line:e8-select-optimistic-path}
implements the Greedy PRM's objective
which trades off between planning and execution cost,
mediated by the parameter $\lambda \in [0,1]$.
Adjusting $\lambda$ varies the behavior between feasible and optimal.
With $\lambda = 0$,
only execution cost is considered,
and the algorithm reduces to the LazyPRM
(assuming it's applied to a simple, single-set problem).

The execution cost component is given by $f_e[x(t)]$
as defined in the cost model $\mathcal{M}$
(Section~\ref{subsec:cost-model}).
The optimistic estimate of the remaining planning cost for the path
is computed by determining the cost of the optimistic plan for each
edge using the \textsc{OptEdgePlan} function
(Section~\ref{subsec:alg-opt-edge-plan}).

\subsection{Path Evaluation}
\label{subsec:alg-path-evaluation}

\begin{algorithm}
\caption{Partial Path Evaluation}
\label{alg:path-evaluation}
\begin{algorithmic}[1]
\Function {\textsc{EvalPath}}{$\pi$}
   \ForAll {$e \in \pi$}
         \label{line:edge-evaluation-order}
      \State $(S_{plan}, b_{plan}, c_{plan})
         = \mbox{\textsc{OptEdgePlan}}(e)$
      \ForAll {$X \in S_{plan}$}
         \State $b_{act} = \mathbf{1}_X[e]$
         \State $\arraycolsep=2pt
            e.P \leftarrow e.P \cup
            \left\{\left( \begin{array}{rl}
            \mathbf{1}_X & \mbox{if } b_{act} \\
            \lnot \mathbf{1}_X & \mbox{otherwise} \\
            \end{array} \right)
            \right\}$
         \If {$b_{act} \neq b_{plan}(X)$}
            \State \Return False
         \EndIf
      \EndFor
   \EndFor
   \State \Return True
\EndFunction
\end{algorithmic}
\end{algorithm}

Once a candidate path is selected,
it is evaluated by the \textsc{EvalPath} function
(Alg.~\ref{alg:path-evaluation}).
Line~\ref{line:edge-evaluation-order} iterates over edges in
the path,
which can be done in any order;
see Section~\ref{subsec:implementation-details} for details.
For each edge $e$,
the planned indicator evaluations are actually performed
(this tends to dominate planning costs).
The evaluation proceeds until an evaluation does not succeed.

\subsection{Implementation Details}
\label{subsec:implementation-details}

We provide an implementation of the Multi-Set PRM
as a plugin for the Open Motion Planning Library \cite{sucan2012ompl}.%
\footnote{Not available during the anonymous review process.}
Here, we discuss a few relevant details of the implementation.

We implement the algorithm's best-first search 
(line~\ref{line:best-first-start} of Alg.~\ref{alg:greedy-prm})
using a bidirectional variant of Dijkstra's algorithm
\cite{dijkstra1959anote}.
This requires that the execution cost functional $f_e[x(t)]$
be additive.
Efficiency could be further increased by applying incremental
graph search algorithms \cite{koenig2004lpastar} to the problem.
We implement the indicator functionals $\mathbf{1}_X[x(t)]$
approximately by evaluating the corresponding indicator functions
$\mathbf{1}_X(x)$ at a fixed resolution along the path.

\subsection{Choosing the Execution Cost Functional}

How to represent execution cost?
Ideally, this would be additive.
Sidd wants me to play with Hauser's fast bounded-velocity,
bounded-acceleration segment timing code
(which starts and stops at each waypoint).

\subsection{Choosing $\lambda$}

Minimizing total time in a greedy fashion implies $\lambda = 0.5$.
For later steps in a multi-step plan,
we might have an estimate of the probability $P_e$ that the given query will
actually be executed.
We can then pose our optimistic objective as total planning and execution
time in expection;
this induces the following parameter choice:
\begin{equation}
   \lambda = \frac{1}{1 + P_e} .
\end{equation}
For example, $P_e=1$ induces $\lambda = 0.5$;
as $P_e \rightarrow 0$, $\lambda \rightarrow 1$.
In other words,
as the estimated probability of executing the path goes down,
the planner becomes greedier w.r.t. planning effort at the expense of
costlier solution paths.

This is all one-step greedy;
it returns the optimal path optimistically,
assuming it will be collision-free.
If we have some estimate of the proportion $P_u$ of evaluated edges
which will be part of the final path,
we can then choose a cost function which downweights the planning time.
I need to work this out.

\section{Results}

Here are results.
See Figure~\ref{fig:bean} and Figure~\ref{fig:herb-comparison-cdfs}.

I hope to show that the Greedy PRM is competitive with RRT-Connect
in terms of planning effort required to find a feasible path.

\begin{figure}
\centering
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-rrtextcon-r1-s1.png}
\caption{RRT Ext-Con, R=1}
\end{subfigure}%
\quad
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-rrtconcon-r1-s1.png}
\caption{RRT Con-Con, R=1}
\end{subfigure}%
\quad
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-checkmask-l00-s1.png}
\caption{Greedy PRM, $\lambda=0$}
\end{subfigure}%
\vspace{0.05in}
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-rrtextcon-r6-s1.png}
\caption{RRT Ext-Con, R=6}
\end{subfigure}%
\quad
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-rrtconcon-r6-s1.png}
\caption{RRT Con-Con, R=6}
\end{subfigure}%
\quad
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figs/compare-2d-rrtc1-checkmask-l10-s1.png}
\caption{Greedy PRM, $\lambda=1$}
\end{subfigure}%
\caption{Example runs with different planners,
   with the same sequence of samples.
   Note that Greedy PRM $\lambda=0$ is equivalent to LazyPRM.
   Red dots show collision checks.}
\label{fig:compare-2d-rrtc1-vis}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figs/compare-2d-rrtc1-medians.png}
\caption{Plot of collision checks vs solution path cost for the
   different algorithms from the problem from
   Figure~\ref{fig:compare-2d-rrtc1-vis}.}
\end{figure}

\begin{figure}
\centering
\begin{subfigure}[b]{0.4\textwidth}
\includegraphics[width=\textwidth]{figs/timegreedy-bean-lambda-00.png}
\caption{Paths with $\lambda = 0$}
\end{subfigure}%
\quad
\begin{subfigure}[b]{0.4\textwidth}
\includegraphics[width=\textwidth]{figs/timegreedy-bean-lambda-10.png}
\caption{Paths with $\lambda = 1$}
\end{subfigure}%
\caption{Examples of paths for a 2d problems
   for different values of $\lambda$.
   As $\lambda$ is increased,
   paths are longer, but are faster to find.}
\label{fig:bean}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figs/timegreedy-herbstep1-comparison-cdfs.png}
\caption{Comparison between different algorithms on a HERB problem.
   Must add in ESTs.}
\label{fig:herb-comparison-cdfs}
\end{figure}

\section{Repeated Queries}

For multiple queries within the same
$\mathcal{C}_{\mbox{\scriptsize free}}$,
the edge evaluations can be used in subsequent searches.
This ends up behaving similarily to E-graphs \cite{phillips2012egraphs}
with $\epsilon=1$
as described in Section~\ref{sec:egraphs},
with the exception that all evaluated edges are placed in the graph,
not just the edges on the solution path.


\newpage
\chapter{Roadmaps in Continuous Spaces}
\label{chap:graphs-in-continuous}

Sweet, sweet chapter about how to best embed explicit graphs
in continuous configuration spaces.

\section{Types of Graphs}

\begin{itemize}
\item Probabalistic vs lattice-based graphs.
\item Probabalistic (pseudo-random) for efficient caching.
\end{itemize}

\section{Optimization in Expectation}

Extend the Greedy PRM algorith to do things in expectation.

Relate to Evan's work.

Motivate the incremental densification idea,
with a graduated cost model
to approximate a probabalistic model
of the $\mathcal{C}$-space.

\section{Batching}

Choosing Batch Size $N$.

What graph are we searching over?
If it's too sparse, we'll stop after knowing that no solution exists.
If it's too dense, we'll spend too much time filling in parts of
space.
There's actually some spatial relationship in
$\mathcal{C}_{\mbox{\scriptsize free}}$ what we're not
modeling.
We get around this with artificial sparseness.
There's definitely a paper's worth of work here too (Shushman's stuff).
The easy version is with sequential batches of size $N$.
Talk about how what we really want to do
is evaluate the estimate of cost remaining
\emph{in expectation}.

Talk about how this is complementary to BIT* which acheive speedups
by batching, not by inflating.

Relate to Markov Random Fields and two-class image segmentation
which capture spatial correlation.

\section{Whole-Path Bisection Testing}

Also talk here about the fancy Lazy PRM path bisection
evaluation function.

\section{The $\mbox{E}^8$ PRM}

This is the planner in continuous spaces,
requires a planning cost model for each edge.

\section{Relaxing the Additive Cost Model Requirement}

Could we do this?
We lose the nice efficient LPA*-enabling structure in
$\mbox{E}^8$ this way,
but it lets us incorporate a more accurate cost model in some domains,
especially for execution costs for fast motions (e.g. total time).

\section{Future Work}

How to handle the narrow passage problem?
Lots of literature on that, new sampling strategies, etc.
(Toggle PRM, for instance.)


\newpage
\chapter{The Multi-Set Planning Problem}
\label{chap:multi-set}

The purpose of this chapter is to introduce the multi-set planning
problem,
talk about its structure in general,
and show how about how a bunch of different problems in manipulation
are instances of this type of problem.

In the introduction to this chapter,
I'll talk about how the multi-step planning problem decomposition
discussed in Chapter~\ref{chap:formulation}
consists of a bunch of different queries in different
$\mathcal{C}_{\mbox{\scriptsize free}}$s, but that are related.

For example, say you're planning to move an object from an initial
location to a goal location,
and then move your manipulator back to the start pose.
See Figure~\ref{fig:manip-example}.
You have a single grasp for the object,
and your manipulator has a single IK for the grasp (very simple problem).
There are three $\mathcal{C}_{\mbox{\scriptsize free}}$s here;
a naive approach would plan separately in each.

\begin{figure}
\centering
\begin{subfigure}[b]{.45\linewidth}
\includegraphics[width=\columnwidth]{figs/simple-table-clearing-task.png}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{.45\linewidth}
\includegraphics{build/multiple-sets}
\end{subfigure}
\caption{
  The set of valid configurations for an articulated robot (left)
  changes often,
  especially in dynamic environments
  and multi-step manipulation problems.
  By describing this structure explicitly as set relations (right)
  and performing best-first search
  minimizing both planning and execution cost,
  we effectively reuse computation between similar
  problems.}
\label{fig:manip-example}
\end{figure}

\section{From RSS Intro}

Motion planning approaches that build graphs
in the collision-free subset of
\emph{configuration space} \cite{lozanoperez1983cspace},
e.g. the
PRM \cite{kavrakietal1996prm}
and RRT \cite{lavallekuffner1999rrt},
have proven promising
for high-dimensional articulated robotics problems
in unstructured environments.
These approaches devote a large amount of computational effort
testing configurations and paths for collision,
and the resulting graph can then be reused
for other queries in the same collision-free subset.

However,
for manipuation problems,
this subset of the robot's configuration space
is sensitive to the locations and shapes of
both people and objects in the environment,
as well as the robot itself.
In addition, it depends on the shape and pose of any object
grasped by the robot.
This makes it difficult not only to apply the results of prior
planning computation to the current problem,
but also to efficiently consider planned or hypothesized motions,
since we must reconstruct our graph from scratch whenever
the environment changes.
This is especially the case for
multi-step manipulation tasks that must be planned into the future.
%We want to continuously update our representation for detours.

A large body of prior work has focused on methods to
improve planning efficiency on manipulation problems,
which we review in Section~\ref{sec:related-work}.
Our first key insight is that many of these approaches are
in fact special instances of a more general structure,
which we formulate as the \emph{multi-set planning problem}
in Section~\ref{sec:multi-set}.

The Multi-Set PRM,
when applied to manipulation problems,
naturally produces an array of efficient behavior.
Section~\ref{sec:in-manipulation} outlines several such instances,
and also provides selected experimental results
on a multi-step manipulation task.
We also provide an open-source implementation of our algorithm.

\section{Motivation}

Imagine a simple ``pick and place'' manipulation planning scenario
in which an articulated robot in a novel cluttered environment
is tasked with moving a particular object from a start pose to a goal
pose in the scene.

\begin{figure}
\centering
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=1.2]
% bounding rect
\draw[color=black!50, thin] (-1.5,-1.5) rectangle (1.5,1.5);
\tikzstyle{dstyle}=[draw=black,fill=black!50]
\input{figs/coll2d/tex-start-w}
\tikzstyle{dstyle}=[draw=black,fill=black]
\input{figs/coll2d/tex-start-r-valid}
%\tikzstyle{dstyle}=[draw=black!50]
%\input{figs/coll2d/tex-start-r-invalid}
\end{scope}
\end{tikzpicture}
\caption{Valid configuration}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=1.2]
% bounding rect
\draw[color=black!50, thin] (-1.5,-1.5) rectangle (1.5,1.5);
\tikzstyle{dstyle}=[draw=black,fill=black!50]
\input{figs/coll2d/tex-start-w}
\tikzstyle{dstyle}=[draw=black,fill=white]
\input{figs/coll2d/tex-start-r-invalid}
\end{scope}
\end{tikzpicture}
\caption{Invalid configuration}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=0.35]

\tikzstyle{every node}=[font=\scriptsize]

% x,y axes
\draw[->] (-3.14,-3.14) -- (4,-3.14) node[anchor=west] {$\theta_1$};
\draw[->] (-3.14,-3.14) -- (-3.14,4) node[anchor=south] {$\theta_2$};

% x tick marks with labels
\draw[-] (-3.14,-3.4) -- (-3.14,-3.14);
\draw[-] (    0,-3.4) -- (    0,-3.14);
\draw[-] ( 3.14,-3.4) -- ( 3.14,-3.14);
\draw	(-3.14,-3.4) node[anchor=north] {$-\pi$};
\draw	(    0,-3.4) node[anchor=north] {$0$};
\draw	( 3.14,-3.4) node[anchor=north] {$\pi$};

% y tick marks with labels
\draw[-] (-3.4,-3.14) -- (-3.14,-3.14);
\draw[-] (-3.4,    0) -- (-3.14,    0);
\draw[-] (-3.4, 3.14) -- (-3.14, 3.14);
\draw	(-3.4,-3.14) node[anchor=east] {$-\pi$};
\draw	(-3.4,    0) node[anchor=east] {$0$};
\draw	(-3.4, 3.14) node[anchor=east] {$\pi$};

% points
\draw[-,style=dotted] (0.2,-3.14) -- (0.2,0.4) -- (-3.14,0.4);
\draw[fill=black] (0.2,0.4) circle (0.15);
\draw[-,style=dotted] (2.1,-3.14) -- (2.1,-2.1) -- (-3.14,-2.1);
\draw[draw=black,fill=white] (2.1,-2.1) circle (0.15);

% legend
\draw[fill=black] (1,3.2) circle (0.15);
\draw	(1,3.2) node[anchor=west] {valid};
\draw[draw=black,fill=white] (1,2.3) circle (0.15);
\draw	(1,2.3) node[anchor=west] {invalid};

\end{scope}
\end{tikzpicture}
\caption{Configuration space}
\end{subfigure}
\caption{A simple planar 2-link manipulator problem.}
\end{figure}


\begin{figure}
\centering
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=1.2]
% bounding rect
\draw[color=black!50, thin] (-1.5,-1.5) rectangle (1.5,1.5);
\tikzstyle{dstyle}=[draw=black,fill=black!50]
\input{figs/coll2d/tex-start-w}
\tikzstyle{dstyle}=[draw=black,fill=black]
\input{figs/coll2d/tex-start-r-start}
%\tikzstyle{dstyle}=[draw=black!50]
%\input{figs/coll2d/tex-start-r-invalid}
\end{scope}
\end{tikzpicture}
\caption{Valid configuration}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=0.35]

\tikzstyle{every node}=[font=\scriptsize]

% x,y axes
\draw[->] (-3.14,-3.14) -- (4,-3.14) node[anchor=west] {$\theta_1$};
\draw[->] (-3.14,-3.14) -- (-3.14,4) node[anchor=south] {$\theta_2$};

% x tick marks with labels
\draw[-] (-3.14,-3.4) -- (-3.14,-3.14);
\draw[-] (    0,-3.4) -- (    0,-3.14);
\draw[-] ( 3.14,-3.4) -- ( 3.14,-3.14);
\draw	(-3.14,-3.4) node[anchor=north] {$-\pi$};
\draw	(    0,-3.4) node[anchor=north] {$0$};
\draw	( 3.14,-3.4) node[anchor=north] {$\pi$};

% y tick marks with labels
\draw[-] (-3.4,-3.14) -- (-3.14,-3.14);
\draw[-] (-3.4,    0) -- (-3.14,    0);
\draw[-] (-3.4, 3.14) -- (-3.14, 3.14);
\draw	(-3.4,-3.14) node[anchor=east] {$-\pi$};
\draw	(-3.4,    0) node[anchor=east] {$0$};
\draw	(-3.4, 3.14) node[anchor=east] {$\pi$};

\begin{scope}[shift={(-3.14,-3.14)},scale=6.28]
\tikzstyle{fdstyle}=[color=black!40, fill=black!20, thin]
\input{figs/coll2d/space-s}
\end{scope}

\end{scope}
\end{tikzpicture}
\caption{Configuration space}
\end{subfigure}%
\quad%
\begin{subfigure}[b]{0.3\textwidth}
\begin{tikzpicture}
\begin{scope}[scale=1.2]
% bounding rect
\draw[color=black!50, thin] (-1.5,-1.5) rectangle (1.5,1.5);
\tikzstyle{dstyle}=[draw=black,fill=black!50]
\input{figs/coll2d/tex-start-w}
\tikzstyle{dstyle}=[draw=black,fill=white]
\input{figs/coll2d/tex-start-r-invalid}
\end{scope}
\end{tikzpicture}
\caption{Invalid configuration}
\end{subfigure}%
\caption{Illustration of solution.}
\end{figure}

If we put some text in here, it shows up in the right place.

\begin{itemize}
\item comes from structure of multi-step problem
\item different cfrees
\item but they're very related!
\item inclusions, intersections
\end{itemize}

See Figure~\ref{fig:multi-set-example} for a simple motivating example.

\begin{figure}
\centering
\begin{tikzpicture}

\node (a) at (0,0) {woo};

\end{tikzpicture}
\caption{An example of different $\mathcal{C}_{\mbox{\scriptsize free}}$s}
\label{fig:multi-set-example}
\end{figure}

\subsection{Multiple sub-queries}

\subsection{Shared C-space}

\subsection{Each in a different C-free}

\subsection{Relations between C-frees (inclusion, intersection)}

\section{Related Work}

The topic of reusing planning computation
between similar motion planning problems
has been extensively studied in different domains.

\subsection{Explicit Configuration Spaces}

Early planning methods constructed explicit obstacles
directly in the configuration space.
This allows reuse via precomputed bitmaps
for translating robots \cite{kavraki1995cspacefft}
or via workspace primitives \cite{newmanbranicky1991cspacetransforms}.
One form of reuse is to precompute these for primitives.
More recently,
Lien and Lu \cite{lien2009similarobstacles} describe a method to
build a PRM around obstacles in a database,
and then reposes them in a new world.
The approach is not easily applicable to articulated robots
with complex mappings from workspace to C-space.

\subsection{Changing Free $\mathcal{C}$-Subsets}

Other approaches attempt to prune and grow graphs
within dynamically changing collision-free subsets,
e.g. the Dynamic RRT \cite{ferguson2006drrt},
the Reconfigurable Random Forest (RRF)
\cite{li2002incrementalprmmanagement},
and the Lazy Reconfiguration Forest
\cite{gayle2007lazyreconfigforest}.
%We do the lazy thing as well (built into our planner).
%None of these reason about the structure of the configuration space.
However, these approaches do not reason explicitly about the
structure of the configuration space.

\subsection{Static vs Dynamic Components of
   $\mathcal{C}_{\mbox{\scriptsize free}}$}

Some approaches do take advantage of such structure
through a two-level dichotomy between
permanent and non-permanent parts of
$\mathcal{C}_{\mbox{\scriptsize free}}$.
Leven and Hutchinson \cite{leven2000changing}
and similar work \cite{kallman2004dynamicroadmaps}
handle changing environments by
precomputing a self-collision-free roadmap,
and then pruning it at query time
using a mapping from workspace cells to roadmap edges.
%This can also be viewed through the multi-space lens
%-- I think this is just an instantiation of a bunch of sets.
%They're very focused on the precomputation stuff.
%However, this approach this can't directly handle grasped objects.
Other methods \cite{jaillet2004dynamicprm}
exploit the dichotomy between static and dynamic parts of
the world online.

\subsection{Task and Motion Planning}

The structure in manipulation tasks that our approach leverages
is similar to the \emph{conditional reachability graph} which is
part of the recent \textsc{FFRob} heuristic task planning framework.
However, the framework is not incentivized to explore
areas of the configuration space that have already been explored.

\subsection{Fast Collision Checking}

Broad-phase collision checking.
See Section~\ref{subsec:broad-phase} for more on this.
I need cites!

\subsection{Sampling Strategies}

Also Kurniawati and Hsu's
\emph{Workspace-based Connectivity Oracle}
\cite{kurniawati2008workconnoracle}
which is a smart sampling strategy which considers workspace
geometry to inform PRM sampling.
Kurniawati has a bunch of other work on PRM fundamentals and sampling.
I think our approach is complementary to a PRM sampling strategy.
Or, you could do deterministic sampling
\cite{lavalle2002gridprms} \cite{geraerts2002prmcomparison}.

\subsection{Multi-Resolution Planning}

\noindent
\begin{itemize}
\item S. Kambhampati 1986
\item R. Steffens 2010
\item S. Zickler 2010
\item K. Gochev 2013
\end{itemize}

\subsection{Graph Search}

Many graph-search approaches are relevant to planning in similar
environments.
Algorithms such as
D* \cite{stentz1994dstar}
or LPA* \cite{koenig2004lpastar}
handle dynamically changing (or incrementally discovered) worlds.
Experience graphs \cite{phillips2012egraphs} are a method to apply
computation from previous graph-search planning queries
to the current problem.
The \textsc{BUGSY} algorithm \cite{ruml2007bugsy}
is most similar to our approach in the way that it explicitly
trades off between planning and execution (solution) cost.

\subsection{Other Related Work to Integrate}

Symbolic planning frameworks.

Newman and Branicky,
\emph{Real-Time Configuration Space Transforms for Obstacle Avoidance}
\cite{newmanbranicky1991cspacetransforms}
is a way to reuse stuff in related worlds.
From Sidd:
\begin{quote}
i know i've told you this before,
but it reminds me of how back in the day
people used to construct cobs
by stamping together cobs for primitives;
it's a form of reuse;
caching old cobs and transforming them for new problems

Here's a paper that talks about approximating C-obstacles.
They have a nice [obvious] theorem in 5.2. Set Containment Property.
\end{quote}

Also \cite{kavraki1995cspacefft}?

Also Kurniawati and Hsu's
\emph{Workspace-based Connectivity Oracle}
\cite{kurniawati2008workconnoracle}
which is a smart sampling strategy which considers workspace
geometry to inform PRM sampling.
Kurniawati has a bunch of other work on PRM fundamentals and sampling.

Jaillet and Simeon,
\emph{A PRM-based motion planner for dynamically changing environments}
\cite{jaillet2004dynamicprm}.
Explicit dichotomy between static and dynamic parts of the world.
Edges are checked when needed against moving obstacles;
their free-ness with respect to each is cached for the last tested position
for each obstacle.

Gayle, Klingler, and Xavier,
\emph{Lazy Reconfiguration Forest}
\cite{gayle2007lazyreconfigforest}.

Li and Shie,
\emph{An incremental learning approach to motion planning with
      roadmap management}
\cite{li2002incrementalprmmanagement}.
This is the Reconfigurable Random Forest (RRF).
They do ``roadmap management'' to handle changing environments,
and talk about doing some simple bounding-box stuff.

Lien and Lu,
\emph{Planning motion in environments with similar obstacles}
\cite{lien2009similarobstacles}.
This builds a PRM around obstacles in a database,
and then reposes them in a new world.

This is very similar to the \emph{conditional reachability graph}
presented by Garrett, Lozano-Perez, and Kaelbling
\cite{garrett2014ffrob}
as part of their task and motion symbolic planning mumbo-jumbo!

Also similar to the way changing environments are handled in PRMs
from Leven and Hutchinson \cite{leven2002changing}.

\section{Multi-Set Problem Formulation}
\label{sec:multi-set}

\begin{figure*}
\begin{widepage}
\centering

\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/figstar-a}
\caption{A two-part multi-set problem in $\mathcal{C}$,
  first between $x_1$ and $x_2$ through $X_{12}$,
  then between $x_2$ and $x_3$ through $X_{23}$.
  The two free sets $X_{12}$ and $X_{23}$ are distinct
  but related.}
\end{subfigure}%
\quad%
\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/figstar-b}
\caption{The free sets are related via other underlying
  subsets of $\mathcal{C}$, with $X_{12}=A \cap B$
  and $X_{23}=A \cap C$.
  A planner solving the first part (from $x_1$ to $x_2$)
  has found paths within $X_{12}$.}
\label{subfig:figstar-intersections}
\end{subfigure}%
\quad%
\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/figstar-c}
\caption{Due to the set relations,
  a planner solving the second part
  (from $x_2$ to $x_3$ in $X_{23}$)
  can reuse any segment known to be in $X_{12}$
  by checking only for its membership in $C$.}
\end{subfigure}

\vspace{0.1in}

\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/example-2d-a}
\includegraphics{build/example-2d-b}
\includegraphics{build/example-2d-c}
\caption{A forklift in a parking lot ($x_1$)
  must retrieve an object ($x_2$)
  and reverse park ($x_3$).
  This two-part problem
  requires plans in distinct collision-free
  $\mathcal{C}$-subsets
  $X_{12}$ and $X_{23}$.}
\label{subfig:figstar-manip-probdef}
\end{subfigure}%
\quad%
\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/example-2d-d}
\includegraphics{build/example-2d-e}
\includegraphics{build/example-2d-f}
\caption{Sets $X_{12}$ and $X_{23}$ are subsets of
  the configuration space of the robot $\mathcal{C}=\mbox{SE}(2)$,
  and can be represented as intersections
  of underlying subsets $A$, $B$, and $C$
  as in Fig.~\ref{subfig:figstar-intersections}.}
\label{subfig:figstar-manip-spaces}
\end{subfigure}%
\quad%
\begin{subfigure}[t]{.32\linewidth}
\centering
\includegraphics{build/example-2d-g}
\includegraphics{build/example-2d-h}
\includegraphics{build/example-2d-i}
\caption{After planning a path from $x_1$ to $x_2$ (top),
  a planner can reuse a configuration in $X_{12}$ (middle)
  by checking only for its membership in subset $C$,
  resulting in plan reuse (bottom).}
\end{subfigure}

\caption{An illustration of a multi-set planning
  problem in a common configuration space $\mathcal{C}$.
  The problem definition generalizes to an artibrary number of
  configuration space subsets and set relations between them.
  When two queries in different subests are solved sequentially,
  a multi-set planner can reuse path segments less expensively.
  See Section~\ref{sec:in-manipulation} for examples in
  manipulation.}
\label{fig:multi-set}
\end{widepage}
\end{figure*}

Here we define the multi-set planning problem,
a generalization of both the movers' problem
and the multi-query planning problem
\cite{kavrakietal1996prm}.
The reader is referred to
Fig.~\ref{fig:multi-set}
for a general example,
as well as a simple instantiation in a 2D manipulation task.
%which is discussed in more detail in
%Section~\ref{subsec:multi-prm-example}.
The multi-set problem formulation
explicitly captures both planning and
solution (execution) cost.

\subsection{Formal Multi-Set Problem Definition}
\label{subsec:problem-definition}

The multi-set planning problem is multi-query in
a fixed configuration space $\mathcal{C}$.
However, unlike related problems in which all
queries demand solution paths contained within a single common subset of
$\mathcal{C}$
(usually the set of collision-free configurations, denoted
$\mathcal{C}_{\mbox{\scriptsize free}}$),
the multi-set problem allows for the specification of
\emph{multiple} such $\mathcal{C}$-subsets
$\mathcal{S} = \{ A, B, \dots \}$.
Like $\mathcal{C}_{\mbox{\scriptsize free}}$,
each member of $\mathcal{S}$
is a subset of the common configuration space
(that is,
$X \subseteq \mathcal{C} \;\forall\; X \in \mathcal{S}$).
For example, in Fig.~\ref{subfig:figstar-manip-spaces},
$\mathcal{C}$-subset $B$
consists of configurations
free of collision between the robot and
the initial object pose.

\begin{figure}
\centering
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics{build/query-to-subset-a}
\caption{Multi-query planning}
\end{subfigure}%
\quad\quad%
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics{build/query-to-subset-b}
\caption{Multi-set planning}
\end{subfigure}
\caption{While queries in multi-query planning reference
  the same subset of $\mathcal{C}$,
  each multi-set query references one of a number of such sets.}
\label{fig:query-to-subset}
\end{figure}

The problem supports an arbitrary number of queries $\mathcal{Q}$.
Each query $q$ references a \emph{single}
$\mathcal{C}$-subset $X_q \in \mathcal{S}$
(see Fig~\ref{fig:query-to-subset}):
\begin{equation}
  q : ( x_{start},\; x_{goal},\; X_q ) .
  \label{eqn:q}
\end{equation}
A continuous feasible solution path $x(t)$ must then satisfy
\begin{equation}
  \begin{array}{c}
  x(t) \in X_q \;\forall\; t \in [0,1] \\
  x(0) = x_{start},\; x(1) = x_{goal} . \\
  \end{array}
  \label{eqn:solution}
\end{equation}
Eqns. (\ref{eqn:q}), (\ref{eqn:solution})
specify single configurations
$x_{start}$ and $x_{goal}$,
but the formulation is trivially extended to start/goal sets.

While simple problems may admit explicit representations of
subsets of $\mathcal{C}$,
recent approaches to complex problems
(e.g. sampling-based planners)
instead reason implicitly via test function(s)
\cite{lavalle2006planningbook}.
To capture this,
we endow each $\mathcal{C}$-subset $X \in \mathcal{S}$ with an
\emph{indicator function} $\mathbf{1}_X(x)$:
\begin{equation}
  \mathbf{1}_X(x) =
    \left\{ \begin{array}{ll}
      \mbox{True} & \mbox{if } x \in X \\
      \mbox{False} & \mbox{otherwise}.
    \end{array} \right.
  \label{eqn:indicator-function}
\end{equation}
Equivalently, the set itself can be defined w.r.t. its indicator:
\begin{equation}
  X = \{ x \in \mathcal{C} \;|\; \mathbf{1}_X(x) = \mbox{True} \} .
\end{equation}
Excusing the abuse of notation,
we define an analogous indicator functional $\mathbf{1}_X[\cdot]$
which operates on path segments $x(t)$.
We use parentheses for functions and brackets for functionals.
\begin{equation}
  \mathbf{1}_X[x(t)] =
    \left\{ \begin{array}{ll}
      \mbox{True} & \mbox{if } x(t) \in X \;\forall\; t \in [0,1] \\
      \mbox{False} & \mbox{otherwise}.
    \end{array} \right.
  \label{eqn:indicator-functional}
\end{equation}
Common examples of such indicators
(\ref{eqn:indicator-function}) or (\ref{eqn:indicator-functional})
include validity checkers for
geometric (workspace) collision,
stability, and visibility constraints.
Note that for complex problems,
evaluation of these indicators 
tends to dominate planning cost.

\begin{figure}
\centering
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics{build/relations-inclusion} \\
$A \subseteq B$ \\
$\mathbf{1}_A \Rightarrow \mathbf{1}_B$
\caption{Containment relation}
\end{subfigure}%
\quad\quad%
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics{build/relations-intersection} \\
$A = B \cap C$ \\
$\mathbf{1}_B \wedge \mathbf{1}_C \Rightarrow \mathbf{1}_A$
\caption{Intersection relation}
\end{subfigure}
\caption{Types of relations used in the paper.
  Each relation can be expressed directly as set relations
  or equivalently as logical statements
  on the corresponding indicator functions
  $\mathbf{1}_X(\cdot)$.}
\label{fig:relations}
\end{figure}

Finally, the multi-set problem incudes a list of set relations
$\mathcal{R}$
between the $\mathcal{C}$-subsets in $\mathcal{S}$.
These can be expressed directly using set theoretic relations,
or equivalently as logical statements
on the corresponding indicator functions.
The two types of relations we use in this paper
(containment and intersection)
are described in Fig.~\ref{fig:relations}.
Fig.~\ref{fig:multi-set} gives an example of intersection relations;
an example of containment is a padded (conservative)
robot model (see Section~\ref{subsec:broad-phase}).

Together, these four elements
(a configuration space $\mathcal{C}$,
subsets $\mathcal{S}$ each with endowed indicators,
a set of queries $\mathcal{Q}$,
and a list of subset relations $\mathcal{R}$)
comprise a multi-set planning problem.

\subsection{Cost Model}
\label{subsec:cost-model}

While the indicators
(\ref{eqn:indicator-function}) and (\ref{eqn:indicator-functional})
are binary,
we are often interested not only in solution feasibility,
but also minimizing a measure of \emph{execution cost}
on the solution path.
Furthermore,
\emph{planning cost} is often also an important consideration.
Here,
we define a cost model $\mathcal{M}$
for multi-set problems
which allows these costs to be captured.

\subsubsection{Execution Cost}
We capture the expected execution cost of a candidate path
$x(t)$ in the space of $\mathcal{C}$-space paths $H$
via a simple functional
\begin{equation}
  f_e : H \rightarrow \mathbb{R}_0^+ .
\end{equation}
We assume that $f_e[x(t)]$ is known and inexpensive to compute.
Common metrics include
execution time (s) or energy (J).

\subsubsection{Planning Cost}
Since indicator evaluation tends to dominate planning costs
in sampling-based planners,
we choose to explicitly penalize such evaluations.
In particular,
each call to indicator functional $\mathbf{1}_X[\cdot]$
incurs a cost given by $f_X[\cdot]$:
\begin{equation}
  f_X : H \rightarrow \mathbb{R}_0^+ .
\end{equation}
We assume that $f_X[\cdot]$ itself is inexpensive to compute.
Common estimates include expected collision checking time (s)
or computational energy required (J).
Often, $f_X[x(t)]$ is proportional to both
the length of the path $x(t)$
and a fixed estimate of the complexity of $\mathcal{C}$-subset $X$.

Together, the execution cost functional $f_e$
and the planning cost functionals $f_X \;\forall\; X \in \mathcal{S}$
comprise the multi-set cost model $\mathcal{M}$.
Note that representing all functionals in common units
(e.g. seconds or Joules) allows a planners
(e.g. the Multi-Set PRM in Section~\ref{chap:multi-set-prm})
to effectively trade off between planning and execution cost.

\subsection{Example Problem}
\label{subsec:multi-prm-example}

Consider the diagram from Fig.~\ref{fig:multi-set}.
$\mathcal{S}$ consists of five $\mathcal{C}$-subsets labeled
$A$, $B$, $C$, $X_{12}$, and $X_{23}$,
and we have two queries,
$q_{12}: (x_1, x_2, X_{12})$
and
$q_{23}: (x_2, x_3, X_{23})$.
$\mathcal{R}$ consists of the two relations
$X_{12} = A \cap B$ and $X_{23} = A \cap C$.
Suppose a cost model $\mathcal{M}$
wherein evaluating the indicator
$\mathbf{1}_A$ incurs cost 4,
evaluating $\mathbf{1}_B$ and $\mathbf{1}_C$ incurs cost 2,
and evaluating $\mathbf{1}_{X_{12}}$ and $\mathbf{1}_{X_{23}}$
incurs cost 6.
In the manipulation example in
Fig.~\ref{subfig:figstar-manip-probdef},
this would be the case if each
pairwise outlined shape collision check incurs unit cost.

Suppose a graph structure within ${X_{12}}$ has been grown to solve
the first query $q_{12}$.
During the subsequent solve of query $q_{23}$,
an existing path segment known to be in ${X_{12}}$ can be shown to
also be contained within ${X_{23}}$ by only evaluating $\mathbf{1}_C$.
In the manipulation example,
reusing an a configuration from the previous search
would require only a check of cost 2,
instead of cost 6 for a new configuration.
Thus, we might hope that a planner may be biased towards reusing
said edges in this case.

For a list of example multi-set problems which arise in manipulation
tasks,
see Section~\ref{sec:in-manipulation}.

\section{Multi-Set Problems in Manipulation Tasks}
\label{sec:in-manipulation}

Instances of multi-set problems are especially prevalent when
planning for manipulation tasks with articulated robots.
This section details several such instances.
While these instances are discussed separately here,
they are often present simultaneously.
See Section~\ref{subsec:herb-experiment}
for experimental results for a problem
which includes several of the multi-set problem instances
described below.

We also provide an implementation for the
OpenRAVE\cite{diankov2010openrave}
virtual kinematic planning environment
which automatically discovers $\mathcal{C}$-subsets
in manipulation tasks.

\subsection{Dynamic Environments}
\label{subsec:dynamic-environments}

\begin{figure}
\centering

\begin{subfigure}[b]{\linewidth}
\centering
\begin{tikzpicture}
\tikzset{>=latex} % arrow heads
\node[anchor=south west,inner sep=0] at (0,0)
  {\includegraphics[width=0.56\columnwidth]{figs/chimp-voxels-delta.png}};

\node[draw,inner sep=3pt,fill=white,fill opacity=0.9,align=center]
  (debrislab) at (-0.7,3.5) {Debris object\\removed};
\node[circle,inner sep=2,draw,fill=white] (debris) at (2.0,2.9) {};
\draw[draw=black, double=white, double distance=1pt, line width=1pt]
  (debrislab.east) -- (debris);
  
\node[draw,inner sep=3pt,fill=white,fill opacity=0.9,align=center]
  (debrislab) at (5.8,5.2) {Additional\\voxels seen};
\node[circle,inner sep=2,draw,fill=white] (debris) at (4.2,5.0) {};
\draw[draw=black, double=white, double distance=1pt, line width=1pt]
  (debrislab.west) -- (debris);
  
\end{tikzpicture}
\caption{A disaster response robot maintains a
  dynamic unstructured environment model
  using coarse voxels
  (scene data from a debris-clearing task at a
  recent disaster response competition).
  Since the last planning query,
  voxels have been added (green) and removed (red).}
\label{fig:chimp-voxels-delta}
\end{subfigure}

\vspace{0.1in}

\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/retroactive-a}
\includegraphics{build/retroactive-b}
\caption{
  $\mathcal{C}$-subsets and relations
  can be added retroactively.
  Here, the graph for an initial query is checked w.r.t $X_1$.
  After environment changes,
  $X_1$ is redefined in terms of the $\mathcal{C}$-subsets
  derived from the set of common, added, and removed elements,
  allowing for reuse on a query in $X_2$.
  Here,
  the planner need only check existing path segments
  against added voxels in order to reuse them for the current query.}
\label{fig:retroactive}
\end{subfigure}

\caption{
  Structured or unstructured dynamic environments
  can be represented as a multi-set problem
  (see Section~\ref{subsec:dynamic-environments}).}
\label{fig:dynamic-environments}
\end{figure}

The sensors on most articulated robots allow them to maintain
dynamic environment models to track changing collision geometry
(see Fig.~\ref{fig:chimp-voxels-delta}).
These models might be
structured (e.g. recognizing objects with known models)
or unstructured (e.g. occupancy models).
In both cases,
even in a changing world,
there are often areas that are fixed between planning queries.

Prior work (e.g. \cite{jaillet2004dynamicprm})
leverages this by imposing a dichotomy between
\emph{fixed} and \emph{moving} components of $\mathcal{C}$.
Our formulation extends this to an arbitrary number of such labels,
including ones defined retroactively (i.e. during planning;
see Fig.~\ref{fig:retroactive}).
By explicitly labeling such areas in workspace
(and leveraging the \emph{set containment} property
\cite{newmanbranicky1991cspacetransforms}),
we can represent this structure as a multi-set planning problem.

Special case of this is if objects are disappearing.

Relation to occupancy grid representations of workspace
(for deltas, conservative approxs, etc).

\subsection{Grasped Objects}
\label{subsec:grasped-objects}

One instance specific to manipulation problems is the handling of
grasped objects.
For example, 
consider a manipulator which grasps a geometric object.
This affects the set of collision-free configurations
across a large section of $\mathcal{C}$
relative to the old set of valid configurations $X_{old}$.
However,
the resulting $\mathcal{C}$-subset $X_{new}$
can be represented simply as
$X_{new} = X_{old} \cap G$,
with $G$ the set of robot configurations in which
the \emph{grasped object} (only)
is deemed free of collision with the robot and environment.
This structure is discussed in the context of the
\emph{conditional reachability graph},
part of the \textsc{FFRob} heuristic framework
\cite{garrett2014ffrob}.

For example,
consider the manipulation problem in
Figure~\ref{fig:testherb-problem}.
The robot must find a path which moves its arm to grasp the cup.
After the cup is grasped,
the robot can reuse any edge in the existing roadmap
but simply checking the grasped cup
against the remainder of the environment.
This structure,
together with the approach to dynamic environments,
are included together in the experimental results
(Section~\ref{subsec:herb-experiment}).

\begin{figure}
\centering
\includegraphics{build/self-collision}
\caption{A roadmap is pre-computed in $R$,
  the subset of $\mathcal{C}$ consisting of configurations free
  of robot self-collision.
  Online, the planner must find a path that's also within $E$,
  the subset free of environment collision.
  When solving this query in $X = R \cap E$,
  the Multi-Set PRM automatically prefers potential paths with
  pre-computed edges (e.g. shown in grey)
  due to lower planning costs over alternatives with lower
  execution costs.}
\label{fig:self-collision-example}
\end{figure}

\subsection{Cached Self-Collision-Checked Roadmaps}
\label{subsec:cached-self-valid}

Self-collision checking is a potentially expensive component to
articulated motion planning;
in contrast to environment checking,
it is fundamentally quadratic in the number of moving links.
Further, pairs of links to be checked
tend to be relatively close to each other,
reducing the effeciveness of broad-phase approaches.

Leven and Hutchinson \cite{leven2000changing}
introduced the concept of a pre-cached roadmap consisting of
configurations and paths already known to be valid w.r.t.
self-collision.
As a type of invariant in $\mathcal{C}$,
this can be seen as a particular instance of multi-set planning.
See Fig.~\ref{fig:self-collision-example}.

\begin{figure}
\centering

\begin{subfigure}[t]{\linewidth}
\centering
\includegraphics{build/broadphase-single}
\caption{A single-set planner testing simply for membership in
  $\mathcal{C}_{\mbox{\scriptsize free}}$
  treats a collision validity checker as a
  ``black box.''
  Internally,
  modern checkers first employ an inexpensive broad-phase check
  using a low-dimensional conservative representation
  to quickly identify non-colliding bodies before
  resorting to an expensive narrow-phase check.}
\end{subfigure}

\vspace{0.2in}

\begin{subfigure}[t]{\linewidth}
\centering
\includegraphics{build/broadphase-multi}
\caption{A multi-set planner can explicitly reason about the
  conservative nature of the broad-phase check.
  This allows it to defer some narrow phase checks
  (often indefinitely)
  and instead prefer paths that require fewer expensive checks.}
\end{subfigure}

\caption{Collision validity checking is a commonly used
  indicator function.
  The multi-set formulation allows an intelligent planner to
  reach inside the checker's ``black box'' and reduce the number
  of costly narrow-phase checks.
  Resulting paths tend to be cheaper to compute and
  stay further from obstacles.}
\label{fig:broad-phase}
\end{figure}

\subsection{Integration with Broad-Phase Collision Checking}
\label{subsec:broad-phase}

\begin{figure}
\centering

\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/paths-lambda0-norel.png}
\caption{
  $\lambda=0$, no broad phase.\\
  Median planning cost: 6650}
\end{subfigure}
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/paths-lambda1-norel.png}
\caption{
  $\lambda=1$, no broad phase.\\
  Median planning cost: 4530}
\end{subfigure}

\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/paths-lambda0-wrel.png}
\caption{
  $\lambda=0$, with broad phase.\\
  Median planning cost: 2122}
\end{subfigure}
\begin{subfigure}[t]{0.45\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/paths-lambda1-wrel.png}
\caption{
  $\lambda=1$, with broad phase.\\
  Median planning cost: 737}
\end{subfigure}

\caption{A simple 2D example of the Multi-Set PRM using
  a broad-phase check.
  Checking for collision with the grey box is 10x less expensive
  than with the actual black obstacle.
  \cdnote{I need to talk about this in the text.}}
\label{fig:broad-phase-2d}
\end{figure}

The multi-set formulation also enables motion planners to
reason directly about different robot or environment models.
For example, consider two geometric robot models,
one with high quality (e.g. from a CAD program),
and one hand-tuned ``padded'' model consisting of 
a small number of simple conservative bounding volumes.
The $\mathcal{C}$-subsets derived from these models,
are related by $R_{padded} \subseteq R_{CAD}$.
Collision checkers currently use a similar approach internally
to speed up collision checks (see Fig.~\ref{fig:broad-phase}.
and Fig~\ref{fig:broad-phase-2d}).

\subsection{Conservative Bounding Volumes for Different Grasps}

\subsection{Conservative Bounding Volumes for Hypothesized Objects}

There's a sweet ICRA paper here.

\subsection{Dual Arm Stuff}

I think this is related.

Check right arm against gian left side box, etc.

\subsection{Dimensionality Reduction}

The Handey \cite{lozanoperez1987handey} robot
assumed a box that contained the wrist links at a range of DOF values.

\section{Other Stuff}

Potential research question: learn cost model over time.


\newpage
\chapter{Applying Greedy PRM to Multi-Set: the Multi-Set Greedy PRM}
\label{chap:multi-set-prm}

\begin{itemize}
\item GreedyPRM and multi-set are complementary
\item Apply greeydprm to multi-set problem
\item one planner that learns, can answer arbitrary queries
   in multiple related spaces faster and faster
\end{itemize}

\section{From RSS Intro}

This computational burden is especially troublesome
in time-sensitive human-scale manipulation tasks
(e.g. from household or disaster response domains).
The costs incurred by the planner
(computation time / electrical energy)
and the robot's motor controllers
(execution time / mechanical energy)
tend to be of comparable magnitude in such domains.
As a result,
we'd like an approach which can reason about both
planning \emph{and} execution costs,
striving for a balance between feasibility and optimality.

Our second key insight
is to apply the principle of best-first search over roadmaps
using an objective which explicitly considers both planning and
execution costs.
The result is the Multi-Set PRM (Section~\ref{chap:multi-set-prm}).
This approach allows the planner to exploit the multi-set structure
inherent in these problems.
%We show the relation of this approach to inflated heuristics
%when applied to traditional graph search over implicit graphs.

\section{Related Work}

Also, there are incremental E-graphs \cite{phillips2013anytimeegraphs}
that we should relate the planner to and compare with.

\section{Implementation Details}

\subsection{Calculating the Optimistic Path Cost}
\label{subsec:alg-opt-path-cost}

The execution cost component is given by $f_e[x(t)]$
as defined in the cost model $\mathcal{M}$
(Section~\ref{subsec:cost-model}).
The optimistic estimate of the remaining planning cost for the path
is computed by determining the cost of the optimistic plan for each
edge using the \textsc{OptEdgePlan} function
(Section~\ref{subsec:alg-opt-edge-plan}).

\begin{algorithm}
\caption{Calculating the Optimistic Edge Plan}
\label{alg:opt-edge-plan}
\begin{algorithmic}[1]
\Function {$\mbox{\textsc{OptEdgePlan}}$}{$e$}
   \State $(S_{best}, b_{best}, c_{best})
      \leftarrow (\mbox{\textbf{nil}}, \mbox{\textbf{nil}}, \infty)$
   \ForAll {$S \in \mathcal{P}(\mathcal{S})$}
         \label{line:power-set}
      \State $c = \sum_{X \in S} f_X[e]$
      \ForAll {$b \mbox{ \textbf{s.t.} }
            b : S \rightarrow \{\mbox{True},\mbox{False}\}$}
            \label{line:all-binary-functions}
         \State $\arraycolsep=2pt
            P_{new} =
            \left\{\left.\left( \begin{array}{rl}
            \mathbf{1}_X & \mbox{if } b(X) \\
            \lnot \mathbf{1}_X & \mbox{otherwise} \\
            \end{array} \right)
            \right|
            X \in S
            \right\}$
         \If {$P_{rels} \cup e.P \cup P_{new}
               \Rightarrow \mathbf{1}_{X_g}$ is valid}
            \If {$c < c_{best}$}
               \State $(S_{best}, b_{best}, c_{best})
                  \leftarrow (S, b, c)$
            \EndIf
         \EndIf
      \EndFor
   \EndFor
   \State \Return $(S_{best}, b_{best}, c_{best})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Calculating the Optimistic Edge Plan}
\label{subsec:alg-opt-edge-plan}

The \textsc{OptEdgePlan} function (Alg.~\ref{alg:opt-edge-plan})
performs the core reasoning which exploits the relations in
the multi-set problem.
Before discussing its implementation,
we first briefly discuss the propositional logic approach
used to reason about the state of each edge.

The planner represents the list of set relations $\mathcal{R}$
(Section~\ref{subsec:problem-definition})
specified in the multi-set problem formulation
as a set of \emph{logical propositions} $P_{rels}$
which are considered globally applicable.
For example,
the proposition $\mathbf{1}_A \Rightarrow \mathbf{1}_B$
follows from the relation $A \subseteq B$
(see Fig.~\ref{fig:relations}).
In addition,
each edge $e$ in the roadmap is augmented with an initially empty
set $e.P$ containing all additional edge-specific propositions
known to be true as a result of any indicator functions evaluated
over that edge.
For example,
if planner evaluated the indicator $\mathbf{1}_B[e]$
and it returned False,
the proposition $\lnot\mathbf{1}_B$ would be added to $e.P$.
Together, such sets of propositions can be used as \emph{premises}
as part of an \emph{argument} to demonstrate a \emph{conclusion};
a logical solver can then be used validate or invalidate the argument.
For example, an argument with these premises and conclusion
$\{ (\mathbf{1}_A \Rightarrow \mathbf{1}_B), (\lnot\mathbf{1}_B) \}
\Rightarrow (\lnot\mathbf{1}_A)$
can be shown to be valid.

The \textsc{OptEdgePlan} function (Alg.~\ref{alg:opt-edge-plan})
is tasked with computing
the optimistically optimal set of indicator evaluations to perform
for the edge in order to validate its membership in the query
$\mathcal{C}$-subset $X_g$.
The function returns three elements:
(a) the set of $\mathcal{C}$-subsets $S \subseteq \mathcal{S}$
whose indicators are to be evaluated,
(b) a binary function $b$
which provides the desired indicator result for each evaluation,
and (c) the total evaluation cost $c$
given by the cost model $\mathcal{M}$'s $f_X[\cdot]$ functionals
(Section~\ref{subsec:cost-model}).

The function proceeds by considering all combinations of
available $\mathcal{C}$-subset indicators $S$ (line~\ref{line:power-set}).
For each set of evaluations,
we compute the planning cost $c$ which would be required.
We then consider all possible outcomes for each indicator
by iterating over all functions $b$ mapping
from $\mathcal{C}$-subset $X$ to binary values
(line~\ref{line:all-binary-functions}).
For each potential outcome $b$,
we form the set of additional propositions $P_{new}$,
and then use a logic solver to determine whether the aggregate
premises imply membership in the query $\mathcal{C}$-subset $X_g$.
If so (and the required cost is the best so far),
we save and return it.

\subsection{Home Robot Manipulation Task}
\label{subsec:herb-experiment}

\begin{figure*}
\begin{widepage}
\centering

\begin{subfigure}[t]{0.185\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-a.png}
\caption{Starting Configuration}
\end{subfigure}
\begin{subfigure}[t]{0.185\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-b.png}
\caption{Step 1, in $X_1$}
\end{subfigure}
\begin{subfigure}[t]{0.185\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-c.png}
\caption{Step 2, in $X_2$}
\end{subfigure}
\begin{subfigure}[t]{0.185\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-d.png}
\caption{Step 3, in $X_3$}
\end{subfigure}
\begin{subfigure}[t]{0.185\linewidth}
\centering
\includegraphics[width=\columnwidth]{figs/testherb-e.png}
\caption{Ending Configuration.}
\end{subfigure}

\caption{
  A home robot performing a three-step manipulation task.
  It must move from its home configuration
  to grasp the cup,
  transfer it to a drop location above the bin,
  and return home.
  Experimental results for the Multi-Set PRM
  are shown in Table~\ref{tab:testherb}}
\label{fig:testherb-problem}
\end{widepage}
\end{figure*}

\begin{table*}
\begin{widepage}
\centering
\footnotesize
\setlength{\tabcolsep}{3pt}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|cc|r@{ }lr@{ }lr@{ }lr@{ }l|r@{ }lr@{ }lr@{ }lr@{ }l|r@{ }lr@{ }lr@{ }lr@{ }l|}
\toprule
\multirow{2}{*}{Relations} & \multirow{2}{*}{Cost}
  & \multicolumn{8}{c|}{$\lambda = 0$}
  & \multicolumn{8}{c|}{$\lambda = 0.5$}
  & \multicolumn{8}{c|}{$\lambda = 1$}
\\
  &
  & Step & 1 & Step & 2 & Step & 3 & \multicolumn{2}{c|}{Total}
  & Step & 1 & Step & 2 & Step & 3 & \multicolumn{2}{c|}{Total}
  & Step & 1 & Step & 2 & Step & 3 & \multicolumn{2}{c|}{Total}
\\ \midrule
\multirow{2}{*}{None} & Plan
  &  6.16&s &  3.72&s &  2.38&s & 12.25&s
  &  5.52&s &  2.89&s &  2.12&s & 10.53&s
  &  3.39&s &  2.25&s &  2.12&s &  7.76&s
\\
  & Exec
  & 14.22&rad &  8.51&rad &  4.23&rad & 26.97&rad
  & 15.07&rad & 10.60&rad &  4.23&rad & 29.89&rad
  & 15.07&rad & 10.60&rad &  4.23&rad & 29.89&rad
\\ [1ex]
Inter-Step & Plan
  &  6.40&s &  2.33&s &  0.86&s &  9.59&s
  &  5.40&s &  1.55&s &  0.91&s &  7.86&s
  &  3.38&s &  0.91&s &  0.30&s &  4.59&s
\\
(Sec.~\ref{subsec:dynamic-environments},~\ref{subsec:grasped-objects})
  & Exec
  & 14.22&rad &  8.51&rad &  4.23&rad & 26.97&rad
  & 15.07&rad & 12.21&rad &  4.23&rad & 31.51&rad
  & 15.07&rad & 12.21&rad &  7.11&rad & 34.40&rad
\\ [1ex]
Self-Checked & Plan*
  &  3.54&s &  2.23&s &  1.17&s & 6.94&s
  &  2.99&s &  1.77&s &  1.16&s & 5.92&s
  &  1.47&s &  1.22&s &  1.16&s & 3.85&s
\\
(Sec.~\ref{subsec:cached-self-valid}) & Exec
  & 14.22&rad &  8.51&rad &  4.23&rad & 26.96&rad
  & 14.22&rad & 10.06&rad &  4.23&rad & 28.51&rad
  & 14.22&rad & 10.60&rad &  4.23&rad & 29.05&rad
\\ [1ex]
\multirow{2}{*}{Both} & Plan*
  &  3.25&s &  1.79&s &  0.90&s & 5.94&s
  &  2.88&s &  1.55&s &  0.92&s & 5.35&s
  &  1.47&s &  1.88&s &  0.31&s & 3.66&s
\\
  & Exec
  & 14.22&rad &  8.51&rad &  4.23&rad & 26.96&rad
  & 14.22&rad &  8.51&rad &  4.23&rad & 26.96&rad
  & 14.22&rad &  9.64&rad &  6.36&rad & 30.22&rad
\\ 
\bottomrule
\end{tabular}
\caption{Home robot manipulation task results.
  The entry with no relations and $\lambda=0$ is equivalent
  to the LazyPRM.}
\label{tab:testherb}
\end{widepage}
\end{table*}

We tested the Multi-Set PRM on the manipulation task
described in Fig.~\ref{fig:testherb-problem}.
We used the $r$-disk PRM construction rule with $r=2.0$ rad,
and a batch size of $N=1000$.
Planning times are measured on a Lenovo T430 laptop.
The planner was asked to solve each of the steps of the plan
sequentially.

We varied
(a) the planning vs. execution parameter $\lambda$
(see Section~\ref{subsec:alg-opt-path-cost}), and
(b) the subset relations provided to the planner
as described in Sections
\ref{subsec:dynamic-environments},
\ref{subsec:grasped-objects},
and \ref{subsec:cached-self-valid}.
We measured the time required for planning (s)
and the length of the resulting solution resulting path (rad)
for each step of the task.

Note that the Multi-Set PRM,
with no relations specified and $\lambda=0$
reduces to the Lazy PRM.
As expected,
increasing $\lambda$ resulted in decreased planning times
but yielded longer paths.
Including more $\mathcal{C}$-subset relations
also significantly reduced planning times,
and had little effect on path lengths on this problem.
Note that the planning time results when using
the cached self-collision-checked roadmap, denoted by (*),
do not include the pre-computation time.

Note that including inter-step relations drastically
reduces planning times for subsequent steps.
We expect this trend would continue as more steps are included.
Also, note that when $\lambda=0$,
path length is unchanged as the number of set relations is
changed
-- this is because the paths that are selected for evaluation
by the algorithm are a function only of their (constant) lengths.

\section{Other Experiments to Run}

\begin{itemize}
\item with/without inter-step relations
\item with/without padding
\item with/without self-checked cache
\item with/without relations for changing worlds
\item with/without conservative boxes for grabbed objects
\item constraints:
   \begin{itemize}
   \item handle with separate planner
   \item handle with relaxed constraint, followed by local optimizer
   \end{itemize}
\item run optimizer on paths occasionally and/or before executing
\end{itemize}


\newpage
\chapter{Comprehensive Multi-Root Planning}

ABSTRACT:
We formulate and study the
\emph{comprehensive multi-root} (CMR) planning problem,
in which feasible paths are desired between multiple regions.
We propose two primary contributions which allow us to extend
state-of-the-art sampling-based planners.
First, we propose the notion of \emph{vertex coloring} as a compact
representation of the CMR objective on graphs.
Second, we propose a method for \emph{deferring edge evaluations}
which do not advance our objective, by way of a simple
criterion over these vertex colorings.
The resulting approach can be applied to any CMR-agnostic 
graph-based planner which evaluates a sequence of edges.
We prove that the theoretical performance of the colored algorithm
is always strictly better than (or equal to)
that of the corresponding uncolored version.
We then apply the approach to the Probabalistic RoadMap (PRM)
algorithm;
the resulting \emph{Colored Probabalistic RoadMap} (cPRM)
is illustrated on 2D and 7D CMR problems.

\section{Introduction}
\label{sec:intro}

Many real-world tasks require a robot to quickly accomplish multiple
subtasks without a prescribed order.
Consider a personal assistant robot
clearing several objects from a tabletop,
or a manufacturing robot performing several welds on a novel workpiece.
Furthermore,
each subtask often permits multiple suitable robot configurations such as
grasps of an object or orientations of a tool.
Even if only one end effector pose is valid,
manipulator redundancy enables many feasible configurations. 
We are interested in efficiently finding feasible paths
for such problems.

For example, consider the robot in Figure~\ref{subfig:herb-picture}.
It is tasked with using a handheld drill to tighten three bolts (blue)
during assembly of a truss structure.
Each bolt permits an entire manifold of permissible robot
configurations which would allow completion of the sub-task,
many of which may be either directly infeasible or difficult to reach
given the environment and other subtasks. We call each of these configurations 
a \emph{root}, and collect all roots which satisfy a particular subtask
into a \emph{root set}. 

The planning problem, then,
can be formulated as finding a diverse set of paths between these
root sets.
We formalize this problem as the \emph{comprehensive multi-root} (CMR)
planning problem (Section~\ref{sec:def}) and ask the question: 
\begin{quote}
How can we efficiently maximize connections between pairs of roots
in \emph{different} root sets?
\end{quote}
Figure~\ref{subfig:cmr-illustration} illustrates a partial solution
to a problem with three root sets where $6$
out of a total possible $27$ connections have been discovered.

\begin{figure}[t]
\centering
\begin{subfigure}[b]{0.6\linewidth}
\centering
\includegraphics[width=\linewidth]{figs/herb-drilling.png}
\caption{A real-world problem.}
\label{subfig:herb-picture}
\end{subfigure}
%\\ \quad \\
\begin{subfigure}[b]{0.35\linewidth}
\centering
\resizebox{\linewidth}{!}{
\begin{tikzpicture}[scale=0.7]

\begin{scope}
\node[rectangle,draw,dotted,
   inner sep=0,minimum height=0.4in,minimum width=0.7in] (x1) at (0,0) {};
\node[below] at (x1.north) {$X_1$};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x1a) at (-0.75,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x1b) at (-0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x1c) at ( 0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x1d) at ( 0.75,-0.2) {};
\end{scope}

\begin{scope}[shift={(-1.5,-2.7)},rotate=120]
\node[rectangle,draw,dotted,rotate=120,
   inner sep=0,minimum height=0.4in,minimum width=0.7in] (x2) at (0,0) {};
\node at (0,0.3) {$X_2$};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x2a) at (-0.75,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x2b) at (-0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x2c) at ( 0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x2d) at ( 0.75,-0.2) {};
\end{scope}

\begin{scope}[shift={(1.5,-2.7)},rotate=-120]
\node[rectangle,draw,dotted,rotate=-120,
   inner sep=0,minimum height=0.4in,minimum width=0.7in] (x3) at (0,0) {};
\node at (0,0.3) {$X_3$};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x3a) at (-0.75,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x3b) at (-0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x3c) at ( 0.25,-0.2) {};
\node[circle,inner sep=0,minimum size=0.05in,fill=black] (x3d) at ( 0.75,-0.2) {};
\end{scope}

\draw (x1b) .. controls(-0.1,-1.7) .. (x2c);
\draw[white,line width=4] (x1a) .. controls(-0.4,-1.7) .. (x3a);
\draw (x1a) .. controls(-0.4,-1.7) .. (x3a);
\draw (x1b) .. controls( 0.1,-1.7) .. (x3a);
\draw (x1a) .. controls(-0.6,-1.7) .. (x2c);
\draw (x3a) .. controls(0.0,-1.8) .. (x2c);
\draw[white,line width=4] (x1d) .. controls( 0.3,-1.7) .. (x3c);
\draw (x1d) .. controls( 0.3,-1.7) .. (x3c);

\end{tikzpicture}
}
\caption{Illustration.}
\label{subfig:cmr-illustration}
\end{subfigure}
\caption{The comprehensive multi-root (CMR) problem.}
\label{fig:cmr-problems}
\end{figure}

\begin{figure*}[t]
\centering
\begin{minipage}{.49\textwidth}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w13-fu1-ec86}
\caption{PRM (86 Edges Checked)\\(195 Edges Considered, No Pairs)}
\label{subfig:w13-sameec-uncolored}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w13-fs1-ec86}
\caption{cPRM (86 Edges Checked)\\(344 Edges Considered, 1 Pair)}
\label{subfig:w13-sameec-colored}
\end{subfigure}
\\ \quad \\
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w13-fu1-ei344}
\caption{PRM (344 Edges Considered)\\(125 Edges Checked, 8 Pairs)}
\label{subfig:w13-sameein-uncolored}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w13-fs1-ei344}
\caption{cPRM (344 Edges Considered)\\(91 Edges Checked, 8 Pairs)}
\label{subfig:w13-sameein-colored}
\end{subfigure}
\end{minipage}
\begin{minipage}{.49\textwidth}
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/plot-edges-w13}
\caption{Edges considered, evaluated, deferred, and skipped.}
\label{subfig:w13-plot-edges}
\end{subfigure}
\\ \quad \\
\begin{subfigure}[b]{\linewidth}
\centering
\begin{tikzpicture}[font=\scriptsize]
% primary axis
\begin{axis}[
   xlabel={Edges Checked},
   ylabel={Pairs Connected},
   %legend pos= north west,
   legend style={at={(axis cs:5,7.5)},anchor=north west},
   legend cell align=left,
   %axis equal image,
   width=\columnwidth,
   height=1.3in,
   xmin=0, xmax=150,
   %xmin=0, xmax=1000, ymin=0,
   %scaled ticks=base 10:-3,
   xlabel near ticks,
   ylabel near ticks]
\addplot[black,ultra thick] table[col sep=space] {figs/w13-fu1-qs-pvc.txt};
\addlegendentry{Uncolored}
\addplot[mark=*,black,only marks,mark size=1,forget plot] plot coordinates {
   (125,8) % uc
};
\addplot[green,thick] table[col sep=space] {figs/w13-fs1-qs-pvc.txt};
\addlegendentry{Colored}
\addplot[mark=*,black,only marks,mark size=1,forget plot] plot coordinates {
   (86,1) %+1
   (87,2) %+1
   (89,4) %+2
   (90,6) %+2
   (91,8) %+2
};
\addplot[blue,mark=o,mark size=2] plot coordinates {(86,0) (86,1)}; % a-b comparison
\addplot[blue,mark=o,mark size=2] plot coordinates {(125,8) (91,8)}; % c-d comparison
% coordinates
\coordinate (subfig_a_point) at (axis cs: 86,0);
\coordinate (subfig_b_point) at (axis cs: 86,1);
\coordinate (subfig_c_point) at (axis cs: 125,8);
\coordinate (subfig_d_point) at (axis cs: 91,8);
\end{axis}
% labels
\node[circle,inner sep=0pt,color=blue,fill=white] (subfig_b_label) at (2.9,0.6) {(b)};
\node[circle,inner sep=0pt,color=blue,fill=white] (subfig_d_label) at (3.1,1.3) {(d)};
\node[circle,inner sep=0pt,color=blue,fill=white] (subfig_a_label) at (4.9,0.5) {(a)};
\node[circle,inner sep=0pt,color=blue,fill=white] (subfig_c_label) at (5.2,1.2) {(c)};
\draw[color=blue,->] (subfig_b_label) -- ($ (subfig_b_point)!4pt!(subfig_b_label) $);
\draw[color=blue,->] (subfig_d_label) -- ($ (subfig_d_point)!4pt!(subfig_d_label) $);
\draw[color=blue,->] (subfig_a_label) -- ($ (subfig_a_point)!4pt!(subfig_a_label) $);
\draw[color=blue,->] (subfig_c_label) -- ($ (subfig_c_point)!4pt!(subfig_c_label) $);
\end{tikzpicture}
\caption{CMR Objective vs edges evaluted.}
\label{subfig:w13-plot-pairs}
\end{subfigure}
\end{minipage}
\caption{A comparison between an
   uncolored~(\ref{subfig:w13-sameec-uncolored},\ref{subfig:w13-sameein-uncolored})
   and colored~(\ref{subfig:w13-sameec-colored},\ref{subfig:w13-sameein-colored})
   forest-of-trees PRM on the same sequence of edges.
   Plot~(\ref{subfig:w13-plot-edges}) shows the evolution of edges in both
   algorithms as they progress,
   and plot~(\ref{subfig:w13-plot-pairs}) shows the number of between-rootset
   pairs found by each.}
\label{fig:example-w13-figstar}
\end{figure*}

We focus our attention on graph-based planners
(e.g. the PRM \cite{kavrakietal1996prm}) 
which build an \emph{explicit} graph approximating the free
configuration space of the robot by incrementally evaluating (for collisions) 
an \emph{implicit} graph comprising edges between sampled vertices
(Section~\ref{sec:cmr-graphs}).
This explicit graph is then queried to find feasible paths between
different roots.

We can abstract these algorithms as edge sources which are emitting
potential edges for evaluation.
Our key insight is to introduce a \emph{deferred edge queue} 
which postpones the evaluation of certain edges in order to
maximize the CMR objective during planning.

We do so by formally representing the CMR objective
in terms of \emph{vertex coloring}.
This naturally suggests an evaluation criterion which we can use to
prioritize some edge evaluations over others (Section~\ref{sec:gen-sol}).
When applied to any edge-evaluating algorithm,
the resulting colored algorithm is provably superior to the original
(Section~\ref{sec:analysis}).

As an example of this approach,
we implemented a colored version of the PRM algorithm
(Section~\ref{sec:colored-prm}),
and applied it to CMR problems in 2D and 7D.

Figure~\ref{fig:example-w13-figstar} shows the results of running
both the uncolored and colored versions of the forest-of-trees PRM
on a 2D problem with two root sets (one at top, one at bottom).
Each algorithm works on the same set of samples;
since they share the same connection rule,
this induces the same set of potential edges.
The remainder of this section calls out the primary features of colored
algorithms by way of this example.

Fig.~\ref{subfig:w13-sameec-uncolored}
and~\ref{subfig:w13-sameec-colored}
compare the tree states of the algorithms
after having performed a collision check on the same number of edges (86).
Bolded edges show the difference between the free-edge
graphs built by each algorithm.
By this point, the colored algorithm has found its first connection between
the two root sets (at right, shown in violet),
whereas the uncolored algorithm has yet to find a connection.
This is possible because the colored algorithm has chosen to defer
evaluation of many edges (shown in light grey).

Fig.~\ref{subfig:w13-sameein-uncolored}
and~\ref{subfig:w13-sameein-colored}
show a different comparison.
In this case,
the tree states are compared after each algorithm has finished considering
the same number of edges (344).
Here, both algorithms have achieved the same objective by
connecting the same number of pairs (8).
However, the tree built by the colored algorithm is a subset of that
built by the uncolored one;
it has therefore performed fewer edge evaluations (91 to 125).

Figure~\ref{subfig:w13-plot-edges} shows the evolution of edges
for each algorithm.
When the uncolored algorithm considers each edge,
it is either checked for collision (below the black line)
or skipped in order to maintain a forest of trees (above the black line).
The colored algorithm additionally maintains a queue of deferred edges
(pattern).
This allows it to perform fewer edge evaluations (below the green line)
for a given input edge.
In Section~\ref{sec:analysis}, we prove that these deferments
do not affect the CMR objective.
The tree state comparisons discussed above are called out in blue.
Each edge evaluation which results in additional connected pairs is
additionally denoted with a black circle.

Figure~\ref{subfig:w13-plot-pairs} shows the number of connected inter-root
pairs as a function of the number of edges evaluated.
The colored algorithm finds its first pair earlier than the uncolored
algorithm (86 vs 125).
Once the colored algorithm finds one pair,
it quickly finds others.
Again, the tree state comparisons are called out in blue.

\section{Related Work}
\label{sec:related}

While our formulation of the CMR problem itself is newly introduced,
so that no existing planners are explicitly tailored for it,
it is intimately related to several classes of well-studied
motion planning problems.

The classical FindPath or mover's problem
\cite{choset2005robotmotion}, \cite{lavalle2006planningbook}
concerns finding a path between two single states.
However,
many approaches are designed to handle connections
between multiple starts, goals, or both.
A problem with multiple starts and goals can be represented as a CMR problem
with $N=2$ root sets.

For example, the original A* algorithm \cite{hart1968astar}
searched for a path between a single start state
and multiple goal states.
While single-query sampling-based algorithms such as the RRT
\cite{lavallekuffner1999rrt}, \cite{kuffner2000rrtconnect}
generally consider a single start and goal state,
extensions \cite{berenson2009manifolds}
have allowed such planners to consider both multiple starts and multiple
goals.
Trajectory optimization can also be applied to the motion planning problem;
while typically considered for single start and goal states,
recent generalizations \cite{dragan2011goalsets}, \cite{schulman2013trajopt}
have extended them to sets of starts or goals.

However, even those approaches that handle start and/or goal sets
typically terminate once a single path is found,
and do not attempt to find multiple diverse connections
between different root sets.

To accomodate more than two root sets,
approaches for multi-query planning
(e.g. \cite{kavrakietal1996prm}) may appear better suited for finding
multiple diverse connections.
For example, they have been used for efficiently solving the single-object
manipulation problem \cite{simeon2004manipulation}.

Additionally, some approaches perform similar deferment on edge
evaluations to our approach.
For example, so-called ``lazy'' algorithms,
such as \cite{bohlin2000lazyprm}, \cite{sanchezante2001sbl}
defer collision checking until edges are to be used.

Other recent work has married symbolic reasoning with geometric planning
for tasks with multiple subtasks
as multi-modal planning \cite{hauser2010multi},
temporal logic \cite{bhatia2010temporalgoals},
or hierarchical or bridged representations and interfaces
\cite{cambon2009hybrid}, \cite{gravot2005asymov},
\cite{srivastava2014taskmotion}.

\section{The Comprehensive Multi-Root Problem}
\label{sec:def}

We work with the robot's configuration space $X$
and its collision-free subset $X_{free}$.
We consider the general problem with $N$ root sets in this space
$\{ X_1, \dots, X_N \}$.
We seek a diverse set of feasible paths between root sets
-- that is, we want to maximize the number of connected roots between sets. 
We call this the \emph{comprehensive multi-root} (CMR) planning problem.

We track progress via the $r$-score:
\begin{equation}
   r = \big| \{
      \textsc{Path}(x_a,x_b) \;|\; x_a,x_b~\text{in different root sets}
      \} \big|.
   \label{eqn:obj}
\end{equation}
For example, the solution illustrated in Figure~\ref{subfig:cmr-illustration}
has an $r$-score of 6 out of a maximum of 27.
Our objective is to \emph{maximize} the $r$-score as \emph{quickly} as
possible.
We define this more formally next.

\section{The CMR Problem on Graphs}
\label{sec:cmr-graphs}

\begin{algorithm}[t]
\caption{Edge Evaluation (graph or forest)}
\begin{algorithmic}[1]
%\Procedure{EvaluateGraph}{$g, v_a, v_b$}
%\If {$\mbox{\textsc{EdgeFree}}(v_a, v_b)$}
%\State $g.E \leftarrow g.E \cup \{ (v_{a}, v_{b}) \}$
%\EndIf
%\EndProcedure
\Procedure{Evaluate}{$g, v_a, v_b$}
\If {$v_a$ and $v_b$ in same connected component}
\State \Return \Comment{Optional, for forest}
\EndIf
\If {$\mbox{\textsc{EdgeFree}}(v_a, v_b)$}
\State $g.E \leftarrow g.E \cup \{ (v_{a}, v_{b}) \}$
\EndIf
\EndProcedure
\end{algorithmic}
\label{alg:edge-evaluators}
\end{algorithm}

We focus on motion planning approaches where
$X_{free}$ is approximated by a graph $g$.
For example,
in a search-based planning approach such as A$^*$ \cite{hart1968astar},
$g$ is a state-lattice,
whereas in a sampling-based planning approach such as the
PRM \cite{kavrakietal1996prm},
$g$ is a random geometric graph.

A key feature of these approaches is that the graph $g$ is \emph{implicit},
i.e. incrementally discovered and/or evaluated as the search progresses.
For example, in a PRM, a sample is drawn at random from $X_{free}$,
all of the local paths to its neighbors on $g$
are evaluated for collisions (using a function
like Algorithm~\ref{alg:edge-evaluators})
and collision-free paths are incrementally added to $g$ as edges.

However, for applications we're interested in,
edge evaluations are expensive \cite{lavalle2006planningbook}
because they require several collision checking queries between
complex geometries.
We therefore want to maximize our objective \eqref{eqn:obj}
while minimizing the number of edges to be checked.
To accomplish this, we return to our CMR objective.

\section{A General Technique for Fast CMR Planning on Graphs}
\label{sec:gen-sol}

We use the structure of the CMR problem
to motivate a new class of algorithms.
We do so by redefining our objective in terms of the graph's structure,
and then describing the two insights which characterize our approach:
\emph{coloring vertices} and \emph{deferring edges}.
We then show how an algorithm can be extended to include these features.

\subsection{Viewing our Objective with Vertex and Graph Colorings}

Consider a graph $g$ in $X_{free}$
applied to a CMR problem.
Here, we show how we can succinctly represent our objective
(\ref{eqn:obj}) with respect to this graph.

We define the \emph{coloring} ${\bf c}(v)$ of vertex $v$ as
\begin{equation}
   \arraycolsep=1.4pt
   %{\bf c}(v) = [c_1, \dots c_N]^\top
   {\bf c}(v) = \hspace{-0.03in} \left[\begin{array}{c}
   c_1 \\ \vdots \\ c_N \\
   \end{array}\right]
   \mbox{ with }
   c_i = \big| \{
      \textsc{Path}(v,x) \;|\; x \in X_i
      \} \big|.
\end{equation}
The coloring\footnote{
Our use of the term ``coloring'' with respect to graph vertices
is not to be confused with the proper graph color assignment problem.}
of a vertex is an $N$-vector,
with each element $c_i$ the number of reachable roots
in the corresponding root set $X_i$ w.r.t. the graph.

Further, we define the \emph{colored norm} $||\cdot||$ as
\begin{equation}
   ||{\bf c}(v)|| = \sum c_i c_j \mbox{ for } i < j.
\end{equation}
The colored norm counts the number of pairs of roots in different root sets
that are connected through the vertex. 

\begin{proposition}
Every vertex in a given connected component $k$ has the same coloring
${\bf c}_k$.
\end{proposition}
\begin{proof}
By definition, every vertex in a connected component has a
\textsc{Path} to every other vertex;
therefore the color of all constituent vertices is equal.
\end{proof}

We now define the colored norm of a connected component as the colored norm
of \emph{any} of its constituent vertices.

Finally, we define the colored norm of a graph $g$
as the sum of the colored norms of all of its connected components:
\begin{equation}
   \label{eqn:colored-norm-graph}
   ||g|| = \sum_k ||{\bf c}_k||
\end{equation}
For a graph solving a CMR problem,
the colored norm of the graph (\ref{eqn:colored-norm-graph})
is equal to the CMR objective (\ref{eqn:obj}).
%\cdnote{Do I need to show this?}

\subsection{Prioritizing Edges via the Graph's Colored Norm}

Due to the expense of evaluating edges
as mentioned in Section~\ref{sec:cmr-graphs},
we endeavor to maximize the CMR objective
(\ref{eqn:colored-norm-graph})
while minimizing the number of edges evaluated.
The reformulation of the objective in terms of graph and vertex coloring
suggests a method to prioritize certain edge evaluations over others.

We first consider the myopic criterion
shown in Algorithm~\ref{alg:criterion}.
When a potential edge between two vertices $v_a,v_b$ is considered,
we determine whether the inclusion of this edge in our graph $g$
would immediately improve our objective.
If so, we proceed to evaluate the edge.

\begin{algorithm}[t!]
\begin{algorithmic}[1]
\Function{MyopicCriterion}{$g, v_a, v_b$}
\State $g'.V \leftarrow g.V$
\State $g'.E \leftarrow g.E \cup \{(v_a, v_b)\}$
\If {$||g'|| > ||g||$}
   \Comment{Check objective}
\State \Return True
   \Comment{Evaluate edge}
\Else
\State \Return False
   \Comment{Do not evaluate edge}
\EndIf
\EndFunction
\Function{Criterion}{$g, v_a, v_b$}%
   \Comment{Balanaced}%
\State $g'.V \leftarrow g.V$
\State $g'.E \leftarrow g.E \cup \{(v_a, v_b)\}$
\If {$||g'|| > ||g||$}
   \Comment{Check objective}
\State \Return True
   \Comment{Evaluate edge}
\ElsIf {exatly one of ${\bf c}(v_a),{\bf c}(v_b)$ is ${\bf 0}$}
\State \Return True
   \Comment{Evaluate edge}
\Else
\State \Return False
   \Comment{Do not evaluate edge}
\EndIf
\EndFunction
\end{algorithmic}
\caption{Myopic and Balanced Edge Criterions}
\label{alg:criterion}
\end{algorithm}

Unfortunately, when initialized with a graph consisting of only
roots,
this criterion will only allow edges which connect directly
between roots of different root sets.
In complex problems, the probability that such edges are feasible
is quite low --
the purpose of intermediate vertices is to find a path within
complex $X_{free}$ spaces.

Therefore, we propose a balanced criterion which allows for exploration
of $X_{free}$.
This approach additionally evaluates edges which would provide an
uncolored vertex (i.e. with ${\bf c}(v) = {\bf 0}$) an initial coloring.

\subsection{A Compact Depiction of Vertex Coloring}

Note that in the graph colored norm test
$||g'|| > ||g||$,
the new graph $g'$ differs from $g$ by a single new edge $(v_a,v_b)$.
In the case that $v_a$ and $v_b$ are already in the same connected component,
the additional edge trivially has no effect on the colored norm,
and the test fails.
Otherwise, the test can be restated as
\begin{equation}
   ||g'|| > ||g||
   \mbox{~iff~}
   ||{\bf c}_a+{\bf c}_b|| > ||{\bf c}_a|| + ||{\bf c}_b||.
\end{equation}
By definition of the colored norm,
taking for brevity ${\bf c}_x = [x_1,\dots,x_N]^\top$,
we can restate the inequality as
\begin{equation}
   \sum_{i<j} (a_i+b_i)(a_j+b_j) > \sum_{i<j} a_i a_j + \sum_{i<j} b_i b_j
\end{equation}
\begin{equation}
   \sum_{i<j} a_i b_j + \sum_{i<j} b_i a_j > 0
\end{equation}
or simply
\begin{equation}
   ||g'|| > ||g||
   \mbox{~iff~}
   a_i,b_j
   \mbox{~nonzero for some~} i \neq j.
   \label{eqn:graphnorm-wrtcolorings}
\end{equation}
Thus,
the result of our criterion for an edge $(v_a,v_b)$
is dependent only on the distribution of nonzero entries of each coloring
${\bf c}_a$ and ${\bf c}_b$.
Therefore, in our examples,
we customarily depict an $N$-coloring of vertices using
binary mixes of $N$ primary colors, e.g.
\[
   \arraycolsep=1.4pt
   {\bf c} : \left[\begin{array}{c}
      2 \\ 0 \\
   \end{array}\right]
   \mapsto
   \mbox{Red},
   \;\;
   {\bf c} : \left[\begin{array}{c}
      0 \\ 1 \\
   \end{array}\right]
   \mapsto
   \mbox{Blue},
   \;\;
   {\bf c} : \left[\begin{array}{c}
      4 \\ 5 \\
   \end{array}\right]
   \mapsto
   \mbox{Violet}.
\]

\begin{figure}[t]
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/queue-intro}
\caption{The edge queue acts as a prioritized buffer
   which only dequeues edges which meet the given criterion
   (\,\tikz[baseline=0.3ex] \fill[color=green, draw=black] (0,0) rectangle (2ex,2ex);\,)
   by indefinitely deferring failing edges
   (\,\tikz[baseline=0.3ex] \fill[pattern=north east lines, pattern color=black!50, draw=black!50] (0,0) rectangle (2ex,2ex);\,).}
\end{subfigure}
\vspace{0.00001in}\\
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/queue-batched}
\caption{The edge source can generate a batch of edges;
   the edge queue then processes until no more can be dequeued.}
\label{subfig:queue-batched}
\end{subfigure}
\vspace{0.00001in}\\
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/queue-interleaved}
\caption{The edge source and edge queue can be interleaved
   so that edges are generated in just-in-time fashion.}
\label{subfig:queue-interleaved}
\end{subfigure}
\caption{Illustration of the edge queue.
   Edges which pass the criterion (shown in solid green)
   are dequeued in first-in-first-out order;
   others (shown in striped grey) remain in the queue.
   The algorithm produces identical results in either batch or
   interleaved operation.
   The examples from
   (\ref{subfig:queue-batched},\ref{subfig:queue-interleaved})
   are from the problem described later in
   Figure~\ref{fig:simple-example}.}
\label{fig:queue}
\end{figure}

\subsection{Deferring Edges}

While a considered edge may fail our criterion early in the planning
process,
because the criterion depends on the state of the graph,
the failed edge may eventually pass once the graph has grown.
Therefore, instead of overlooking a failed edge entirely,
we instead defer it until subsequent iterations.
To support this, we propose the introduction of a 
\emph{deferred edge queue}.
The mechanics of this queue are illustrated in Figure~\ref{fig:queue}.

The edge queue can be implemented as a priority queue with
binary priority $\{ low, high \}$
such that
(a) only elements with $high$ priority are dequeued,
(b) elements with the same priority are dequeued in FIFO order,
and (c) element priorities can be changed.

\begin{algorithm}[t]
\begin{widepage}

\begin{minipage}{.43\textwidth}
\begin{algorithmic}[1]
\Procedure{GenericAlgorithm}{}
\State $g.V \leftarrow \emptyset$; $g.E \leftarrow \emptyset$
\State
\Loop
\State $(v_a,v_b) \leftarrow \mbox{\textsc{GetNextEdge}}()$
\State $\mbox{\textsc{Evaluate}}(g, v_a, v_b)$%
   \Comment{graph or forest}%
\EndLoop
\EndProcedure
\end{algorithmic}
\end{minipage}
\;
\begin{minipage}{.55\textwidth}
%\definecolor{light-gray}{gray}{0.9}
\begin{algorithmic}[1]
\Procedure{GenericColoredAlgorithm}{}
\State $g.V \leftarrow \emptyset$; $g.E \leftarrow \emptyset$
\State $Q_{edge} \leftarrow \emptyset$
   \Comment{Initialize an empty edge queue}%
\Loop
\State $(v_a,v_b) \leftarrow \mbox{\textsc{GetNextEdge}}()$
\State $\mbox{\textsc{Consider}}(g, Q_{edge}, v_a, v_b)$
   \Comment{Instead of \textsc{Evaluate}}%
\EndLoop
\EndProcedure
\end{algorithmic}
\end{minipage}

\vspace{0.05in}
\rule{\textwidth}{.1pt}%

\begin{algorithmic}[1]
\Procedure{Consider}{$g, Q_{edge}, v_a, v_b$}
\State $Q_{edge}.\mbox{\textsc{Push}}((v_a, v_b))$
\While {$(v_a,v_b) = Q_{edge}.\mbox{\textsc{PopFiltered}}()
      \mbox{~using~} \mbox{\textsc{Criterion}}(g, \cdot)$}
   \Comment{Dequeue first edge meeting criterion}%
   \label{line:color-check}%
\State $\mbox{\textsc{Evaluate}}(g, v_a, v_b)$%
   \Comment{graph or forest}%
\EndWhile
\EndProcedure
\end{algorithmic}

\caption{Converting a Generic Algorithm to Use the Colored Edge Queue}
\label{alg:generic-comparison}
\end{widepage}
\end{algorithm}

Such an edge queue can be introduced into any incremental graph construction
algorithm.
In the case that the edge adjacency rule for each considered edge
is independent of past edge evaluations,
the proofs in Section~\ref{sec:analysis} provide theoretical guarantees
on performance as a result of the introduction of the queue.

An example of introducing the colored edge queue into a generic algorithm
is shown in Algorithm~\ref{alg:generic-comparison}.
Note that while the edge source and queue processing can be batched,
we show the interleaved case for convenience.
During queue processing,
each edge (in the order it was enqueued)
is considered relative to our criterion (line~\ref{line:color-check}).
In the case that an edge passes this check,
it is dequeued for evaluation;
otherwise, it is deferred until later, remaining in the queue.
The dequeued edge is then evaluated according to the traditional
\textsc{Evaluate} rule (e.g. forest-of-trees).

The introduction of the deferred edge queue based on our criterion
produces the behavior seen in Figure~\ref{fig:example-w13-figstar}.
A more illuminating example is shown in
Figure~\ref{fig:simple-example}.

\section{Analysis}
\label{sec:analysis}

Here, we analyze and compare a generic forest-of-trees (i.e. forest)
algorithm with its colored variant
(as shown in Algorithm~\ref{alg:generic-comparison}).
The proofs in this section depend on two lemmas which we investigate
in turn.
%We show that the colored algorithm's $r$-score is always at least
%as high as that found by the uncolored algorithm,
%with the colored algorithm doing at most as much work as the uncolored one.

\begin{figure}[t]
%\vspace{0.1in}
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/simpleex-classical}
\caption{The uncolored algorithm evaluates each edge immediately.}
\end{subfigure}
\vspace{0.00001in}\\
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/simpleex-colored}
\caption{The colored algorithm defers edge $B$ until a pair is found.}
\end{subfigure}
\vspace{0.00001in}\\
\begin{subfigure}[b]{0.49\linewidth}
\centering
\includegraphics{build/simpleex-queuestate}
\caption{Queue state}
\label{subfig:results}
\end{subfigure}
\begin{subfigure}[b]{0.49\linewidth}
\centering
\includegraphics{build/simpleex-pairsvchecks}
\caption{Pairs vs Work}
%\label{subfig:results}
\end{subfigure}
\caption{A very small problem as an example.
   Edges are considered by both algorithms in order A,B,C.
   The colored algorithm achieves a higher $r$-score earlier
   by deferring edge B.}
\label{fig:simple-example}
\end{figure}

\subsection{Criterion Failure Transitivity}

\begin{lemma}
Given a graph $g$ and three of its constituent vertices
$v_a$, $v_b$, and $v_c$,
if $\textsc{Criterion}(g, v_a, v_b)$
and $\textsc{Criterion}(g, v_b, v_c)$ both evaluate to False,
then $\textsc{Criterion}(g, v_a, v_c)$ also evaluates to False.
\label{lem:failure-transitivity}
\end{lemma}

\begin{proof}
If the criterion evaluates to False for both
$(v_a,v_b)$ and $(v_b,v_c)$,
then it implies two propertices of their colorings
${\bf c}_a$, ${\bf c}_b$, and ${\bf c}_c$.
First, either they are all zero or they are all nonzero.
Second, from (\ref{eqn:graphnorm-wrtcolorings}) it holds that
that $a_i b_j = 0 \;\forall\; i \neq j$
and $b_j c_k = 0 \;\forall\; j \neq k$.

In the case that they are all the zero coloring,
then $\textsc{Criterion}(g, v_a, v_c)$ is trivially False.

If they are all nonzero,
there must be some nonzero element $b_j$ in ${\bf c}_b$.
It therefore holds that
$a_i = 0 \;\forall\; i \neq j$
and $c_k = 0 \;\forall\; k \neq j$.
Thus, $a_i c_k$ can only be nonzero if $i=j=k$,
implying that $a_i c_k = 0 \;\forall\; i \neq k$.
By (\ref{eqn:graphnorm-wrtcolorings}),
this shows that $\textsc{Criterion}(g, v_a, v_c)$
evaluates to False.
\end{proof}

%\subsection{Proof of Colored Subset for Full Graph}
%
%\cdnote{I might not bother with these proofs,
%and instead just say that the forest proofs are
%harder and more interesting anyway.}
%
%\begin{theorem}
%For the same sequence of edges,
%every edge evaluated by the
%graph $\mbox{\textsc{NColoredPRM}}$
%is also evaluated by the
%classical graph $\mbox{\textsc{PRM}}$.
%\end{theorem}
%
%\begin{proof}
%\cdnote{This is rather trivial.}
%\end{proof}

\subsection{Comparative Analysis via a Composite Algorithm}
\label{sec:proof-forest}

For the purpose of comparing the uncolored and colored forest
algorithms,
we consider the behavior of both algorithms
considering the same sequence of edges $\{ e_1, e_2, \dots \}$.
When a new edge in the sequence is considered,
the composite algorithm
first allows the uncolored version to update,
and then allows the colored version to update.
While the algorithms evolve independently,
we can directly compare their behavior because they
share the same set of potential edges.

We track the state of each algorithm by assigning one of four labels
to each considered edge:

\begin{tabular}{cl}
$Q$ & in the queue \\
$F$ & evaluated and collision-free \\
$C$ & evaluated and in collision \\
$S$ & skipped due to forest constraint \\
\end{tabular}

To compare the progress of the uncolored and colored algorithms,
each considered edge is tagged using a pair of these labels.
For example, an edge labeled $FQ$
has been evaluated to be collision-free by the uncolored algorithm,
but is still in the queue of the colored algorithm.
There are sixteen possible composite labels.

The proofs in this section rely on a proposed invariant over these
composite labels.
Once we have shown that the invariant holds,
we can use it to prove relations between the trees built by each algorithm.

\vspace{0.05in}

\begin{invariant}
Every composite label for a considered edge is in
$\{ QQ, FQ, CQ, SQ, FF, CC, SS \}$.
\label{inv:pairwise-labels}
\end{invariant}

\vspace{0.05in}

\begin{lemma}
Invariant~\ref{inv:pairwise-labels} holds throughout the composite
algorithm.
\label{lem:pairwise-labels}
\end{lemma}

\begin{proof}
To prove Lemma~\ref{lem:pairwise-labels},
we show that it is true at the start of execution,
and then show inductively that it is maintained throughout execution
of the composite algorithm.
See Figure~\ref{fig:pairwise-labels} for an illustration of allowed
transitions that we demonstrate here.

Base case: When the composite algorithm begins,
no edges have yet been considered,
so the invariant is trivially true.

\begin{figure}
\centering
\input{build/pairwise-labels-dot}
\caption{Possible composite label transitions.
   Section~\ref{sec:proof-forest} proves that the red states
   can never be reached.}
\label{fig:pairwise-labels}
\end{figure}

When a new edge is considered,
it is placed in both queues with label $QQ$
(and the invariant holds).

Next, the uncolored algorithm updates.
Since edges in its queue are always immediately considered,
the edge is dequeued and evaluated.
Depending on the connectivity of the space and the existing graph,
each transitions to one of $\{ FQ, CQ, SQ \}$ (and the invariant holds).
When finished, the uncolored queue is empty,
and so no edges remain as $QQ$.

Next, the colored algorithm updates.
Zero or more edges are iteratively dequeued
because they satisfy the $\textsc{Criterion}$.
Each edge dequeued is initially labeled as one of $\{ FQ, CQ, SQ \}$.
We consider each case in turn.

If the dequeued edge $e_i$ (connecting $v_a$ and $v_b$)
is labeled $FQ$ or $CQ$,
we first show that it cannot transition to $FS$ and $CS$, respectively.
Imagine that it did get skipped by the colored algorithm.
That would imply an existing path $P$ through the colored graph
between $v_a$ and $v_b$ consisting of edges of type $XF$.
Due to our invariant, such existing edges must be $FF$.
But, then, the uncolored algorithm would have also skipped it.
Therefore, dequeued edges having $FQ$ or $CQ$ cannot transition to
$FS$ and $CS$, respectively.

Furthermore, $FQ$ cannot transition to $FC$, since that would imply
that the two algorithms evaluated the same edge yielding a different result.
Similarly, $CQ$ cannot transition to $CF$.
Therefore, $FQ$ must transition to $FF$
and $CQ$ to $CC$,
and the invariant holds.

Last, we consider the case that the dequeued edge
$e_i$ is labeled $SQ$.
Since it was skipped by the uncolored algorithm,
it must have been in the same connected component w.r.t. the uncolored
graph at the time it was considered.
Therefore, there must be a path $P$ of edges $(e_{p_1}, e_{p_2}, \dots)$
consisting of \emph{earlier} edges (i.e. $p_j < i$)
through $X_{free}$, such that each edge $e_{p_1}$ is labeled $FX$
for some colored label $X$.
In fact, due to our invariant, each edge must be either $FQ$ or $FF$.

We now show that it is impossible for any edge in $P$ to be $FQ$.
For a moment, consider that one or more edges in $P$ are $FQ$.
Since all edges in $P$ are earlier than $e_i$,
all that are $FQ$ must not satisfy the $\textsc{Criterion}$,
or they would have been dequeued before $e_i$.
By Lemma~\ref{lem:failure-transitivity},
the endpoints of $P$ must therefore also fail $\textsc{Criterion}$.
However, since edge $e_i$ was dequeued,
its vertices $v_a, v_b$ must simultaneously satisfy $\textsc{Criterion}$.
Due to this contradiction, we know that no edges on $P$ are $FQ$.

Therefore, all edges in $P$ must be $FF$,
and $e_i$ will be skipped by the colored algorithm
because both $v_a$ and $v_b$ are in the same connected component.
Therefore, $e_i$ will receive $SS$, and the invariant holds.
\end{proof}

\begin{algorithm*}[t]
\caption{Colored PRM}
\begin{algorithmic}[1]
\Procedure{ColoredPRM}{$\{X_1, \dots, X_N\}$}
   \Comment{Algorithm initialized with $N$ root sets}%
\State $g.V \leftarrow \emptyset$; $g.E \leftarrow \emptyset$
   \Comment{Initialize with empty graph}%
\State $Q_{edge} \leftarrow \emptyset$
   \Comment{Initialize edge queue}%
   \label{line:empty-queue}%
\While {$\mbox{\textsc{Continue}}(g)$}
   \Comment{Run until termination}%
\If {all roots not added}
   \label{line:roots-not-added}%
\State $v_{new} \leftarrow \mbox{\textsc{NextRoot}}(\{X_1, \dots, X_N\})$
   \Comment{Initially add each root to the graph}%
   \label{line:add-root}%
\Else
\State $v_{new} \leftarrow \mbox{\textsc{SampleFree}}()$
   \Comment{Sample a vertex in free space}%
   \label{line:sample}%
\EndIf
\State $g.V \leftarrow g.V \cup \{ v_{new} \}$
   \Comment{Add vertex to graph}%
   \label{line:island-add}%
\For {$v_{near} \in \mbox{\textsc{Nearby}}(g, v_{new})$}
   \Comment{Consider all existing nearby vertices}%
   \label{line:nearby}%
\State $\mbox{\textsc{Consider}}(g, Q_{edge}, v_a, v_b)$%
   \label{line:consider}%
\EndFor
\EndWhile
\EndProcedure
\end{algorithmic}
\label{alg:colored-prm}
\end{algorithm*}

\subsection{Theoretical Proofs}

\begin{theorem}
For the same sequence of edges,
the free-edge graph built by the
uncolored forest algorithm
is a subset of that built by the
colored forest algorithm.
\label{thm:forest-tree-subset}
\end{theorem}

\begin{proof}
To prove Theorem~\ref{thm:forest-tree-subset},
it is sufficient to show that no edge is non-free in the uncolored algorithm
and free in the colored algorithm.
Under our labeling, such an edge would have a label in
$\{ QF, CF, SF \}$.
Lemma~\ref{lem:pairwise-labels} asserts that
such a labeling is impossible.
\end{proof}

\begin{theorem}
For the same sequence of edges,
every edge evaluated by the
colored forest algorithm
is also evaluated by the
uncolored forest algorithm.
\label{thm:forest-less-work}
\end{theorem}

\begin{proof}
To prove Theorem~\ref{thm:forest-less-work},
it is sufficient to show that no edge is both
unevaluated by the uncolored algorithm
and evaluated by the colored algorithm.
Such an edge would have a label in
$\{ QC, QF, SC, SF \}$.
Lemma~\ref{lem:pairwise-labels} asserts that
such a labeling is impossible.
\end{proof}

\begin{theorem}
For the same sequence of edges,
after both algorithms have finished processing,
the free-edge graph built by the
colored forest algorithm
has the same colored norm $||g||$
as that built by the
uncolored forest algorithm.
\label{thm:forest-same-score}
\end{theorem}

\begin{proof}
To prove Theorem~\ref{thm:forest-same-score},
we show that the value of the colored norm of the graph built by the
colored algorithm $||g_c||$
can be neither greater than nor less than
that built by the uncolored algorithm $||g_u||$.

First, since we have shown in Theorem~\ref{thm:forest-tree-subset}
that the colored free-edge graph is a subset of the uncolored free-edge
graph,
it follows directly that every pair of roots connected by $g_c$
must be also connected by $g_u$.
Therefore, $||g_c||$ must not be greater than $||g_u||$.

Next, we suppose that $||g_c||$ is less than $||g_u||$
after both algorithms have processed their queues.
In such a case,
there must exist a pair of roots $v_a$, $v_b$ in different root sets
that are connected through $g_u$,
but not through $g_c$.
Consider such a path $P$ connecting $v_a$ and $v_b$;
since it connects through $g_u$,
it must be composed of composite edges labeled $FQ$ or $FF$
due to Lemma~\ref{lem:pairwise-labels}.
Since the colored queue has finished processing,
every edge labeled $FQ$ must fail $\textsc{Criterion}$.
By Lemma~\ref{lem:failure-transitivity},
the endpoints of $P$ must therefore also fail $\textsc{Criterion}$.
However, because $v_a$ and $v_b$ are in different root sets,
they must satisfy $\textsc{Criterion}$.
This contradiction proves that
$||g_c||$ must not be less than $||g_u||$.
\end{proof}


\subsection{Conclusion}

Due to Theorems~\ref{thm:forest-less-work}
and~\ref{thm:forest-same-score},
we have shown that after each iteration,
the colored forest algorithm achieves the same CMR objective score
as the uncolored algorithm,
while performing fewer (or equal) edge evaluations.

%\subsection{Algorithm Complexity}
%
%It may be a good idea to discuss how the additional components in the
%algorithm relative to the classical PRM
%(e.g. the deferred edge queue)
%affect the computational complexity of the algorithm.
%I expect that worst-case performance may be worse,
%but for practical problems collision-checking time will dominate.
%
%The only downsides I can think of for our algorithm are
%(a) marginal increasing in size per vertex to store color,
%(b) additional edge queue, which may grow to be large
%[there may be efficient ways of storing this],
%and (c) having to spread colors around
%[this could probably be handled with a connected component data structure].
%Seems like these are things to touch on in the discussion section.

\section{The Colored PRM Algorithm}
\label{sec:colored-prm}

To illustrate the performance of the coloring approach,
we applied it to the PRM.
The resulting algorithm, the \textsc{ColoredPRM},
is shown in Algorithm~\ref{alg:colored-prm}.
Note that we commit to
neither a particular termination criterion $\mbox{\textsc{Continue}}$,
a sampling procedure $\mbox{\textsc{SampleFree}}$,
nor an edge evaluation function $\mbox{\textsc{EdgeFree}}$.
%We discuss difference choices from the literature later in the paper.
Note that we also don't specify $\mbox{\textsc{Nearby}}$;
indeed, the colored queue can be introduced into any algorithm
which searches over edges of an incrementally-constructed implicit graph
(e.g. classical PRM, $r$-disk PRM, etc)
in any order (e.g. nearest first, etc).

The algorithm begins with an empty edge queue
(line~\ref{line:empty-queue}).
Each iteration proceeds as a classical PRM;
a new vertex is sampled from $X_{free}$ and added to the graph
(lines~\ref{line:roots-not-added}-\ref{line:island-add}),
and we iterate over a subset of existing vertices
(e.g. within a radius) in some order (e.g. by increasing distance)
(line~\ref{line:nearby}).
Whereas a classical PRM would immediately evaluate each edge,
we instead call \textsc{Consider} as defined in
Algorithm~\ref{alg:generic-comparison} (line~\ref{line:consider}).
This enqueues the edge and then processes the queue.

\subsection{Qualitative Behavior}

\begin{figure}[t]
\centering
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w10005-fu4-ec434}
\caption{PRM, 434 Checked\\(1570 Considered, $r=0$)}
%\label{subfig:uncolored}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w10005-fs4-ec434}
\caption{cPRM, 434 Checked\\(3357 Considered, $r=1$)}
%\label{subfig:colored}
\end{subfigure}
\\ \quad \\
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w10005-fu4-ei3357}
\caption{PRM, 3357 Considered\\(738 Checked, $r=100$)}
%\label{subfig:uncolored}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics{build/w10005-fs4-ei3357}
\caption{cPRM, 3357 Considered\\(452 Checked, $r=100$)}
%\label{subfig:colored}
\end{subfigure}
\\ \quad \\
\begin{subfigure}[b]{\linewidth}
\centering
\includegraphics{build/plot-edges-w10005}
\caption{Edges considered, evaluated, deferred, and skipped.}
\label{subfig:results}
\end{subfigure}
\caption{The cPRM indefinitely defers edges in unreachable regions.
Here we view snapshots of the PRM and cPRM operating with the same sequence
of edges considered.}
\label{fig:unreachable}
\end{figure}

The forest-of-trees \textsc{ColoredPRM}
evolves similarly to its uncolored variant,
with two exceptions.
First, edges between the same root set are initially deferred.
Second, edges that are in unreached portions of the state space
are entirely deferred.
This is most clearly exemplified in Figure~\ref{fig:unreachable}.
This tends to induce behavior reminiscent of a multi-directional RRT.

\subsection{Complex 7-DOF Manipulator Drilling Problem}

We applied the \textsc{ColoredPRM} to a drilling problem on the HERB
robot \cite{srinivasa2012herb20}, shown in Figure~\ref{subfig:herb-picture}.
Drill poses and manipulator inverse kinematic solutions for the 7-DOF
arm were discretized and tested for collision;
the resulting root sets contained 25, 112, and 142 roots.
Together with the single starting configuration comprising its own root set,
the problem consisted of four root sets with a total of 280 roots.
Both the uncolored and colored variants of the PRM were run
with the same set of samples with an $r$-disk radius of 3.0 rad
and collision checking resolution of 0.02 rad.

The results are shown in Figure~\ref{fig:herb-drilling}.
The first pair was found after 3572 edge evaluations (5802 collision checks)
The four root sets were fully connected after 5310 edge evaluations
(23627 checks).

For the uncolored PRM,
this compares to 5675 edge evaluations (15493 checks)
until the first pair was found,
and 7314 edge evaluations (32861 checks) until the sets
were fully connected.

\begin{figure}[t]
\centering
\includegraphics{build/plot-edges-drill}
\caption{Edge evolution for the HERB drilling problem.}
\label{fig:herb-drilling}
\end{figure}

\section{Discussion}
\label{sec:discussion}

We formulated the comprehensive multi-root (CMR) planning problem,
and by representing its objective over a graph using vertex coloring,
we motivated the introduction of a deferred edge queue into
incremental graph building algorithms.
We proved that the resulting colored algorithms
are superior to their uncolored counterparts for the CMR problem,
and showed examples in both 2D and 7D spaces.

In this paper, we did not consider optimality of the solution,
opting instead to focus on the forest-of-trees approach to graph building.
We note, however, that our criterion applies equally well to full graphs;
indeed it induces similar behavior to a forest-of-trees approach
for all roots until they become connected to another root set.
It can also be applied to  asymptotically-optimal variants of these planners
\cite{karaman2011samplingoptimal}.


\newpage
\chapter{Task Planning}
\label{chap:task-planning}

\subsection{The \textsc{Proteus} Task Planner}

Uses CMR.
Runs separate Multi-Set PRMs.

Proteus Reasons Over Task Effort Using Sampling.


\newpage
\chapter{Conclusion}


\newpage
\chapter[Summary of Proposed Work]{Summary of\\Proposed Work}

\section{Research Questions}
\label{sec:research-questions}

List of research questions.

\begin{center}
\begin{tabular}{llc}
\toprule
   \multicolumn{2}{l}{Research Question}
      & Chapter \\
\midrule
   \ref{ques:choosing-lambda}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:choosing-lambda}
      \end{minipage}%
      & \ref{chap:inflate} \\[10pt]
   \ref{ques:incremental-search}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:incremental-search}
      \end{minipage}%
      & \ref{chap:inflate} \\[10pt]
   \ref{ques:batching}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:batching}
      \end{minipage}%
      & \ref{chap:graphs-in-continuous} \\[10pt]
   \ref{ques:multi-set-suited}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:multi-set-suited}
      \end{minipage}%
      & \ref{chap:multi-set-prm} \\[10pt]
   \ref{ques:how-sequence}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:how-sequence}
      \end{minipage}%
      & \ref{chap:task-planning} \\[10pt]
   \ref{ques:drc-compare}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:drc-compare}
      \end{minipage}%
      & \ref{chap:task-planning} \\[10pt]
   \ref{ques:herb-performance}
      &
      \begin{minipage}[c]{0.8\columnwidth}%
      \nameref{ques:herb-performance}
      \end{minipage}%
      & \ref{chap:task-planning} \\[6pt]
\bottomrule
\end{tabular}
\end{center}

{
%\renewcommand\thesubsection{\thesection.Q\arabic{subsection}}
\renewcommand\thesubsection{Q\arabic{subsection}}

\subsection{How should the $\lambda$ parameter mediating
   between planning and execution cost be chosen?}
\label{ques:choosing-lambda}

See Chapter~\ref{chap:inflate}.

\subsection{How can incremental graph search ideas (e.g. LPA*)
   be used to efficiently implement the $\mbox{E}^8$ algorithm?}
\label{ques:incremental-search}

See Chapter~\ref{chap:inflate}.

\subsection{What is the best way to handle batching?}
\label{ques:batching}

Chapter~\ref{chap:graphs-in-continuous}
discusses how to embed roadmaps in $\mathcal{C}$
so that they can be searched by $\mbox{E}^8$.

The problem with na\"{\i}vly running $\mbox{E}^8$ on a
dense roadmap in $\mathcal{C}$
is that it tends to bunch up in local minima.
This is because reducing the continuous planning problem
to a graph search ignores the spatial correlation
inherent in $\mathcal{C}_{\mbox{\scriptsize free}}$.

One way to capture this is to maintain a probabalistic model
of $\mathcal{C}_{\mbox{\scriptsize free}}$,
and then optimize in expectation.
In particular,
instead of greedily choosing the best path based on
optimistic estimates of one-time planning and execution cost:
\begin{equation}
   f(\pi) = \lambda \hat{f}_p(\pi) + (1-\lambda) \hat{f}_x(\pi),
\end{equation}
we instead reason over the total \emph{expected} remaining cost:
\begin{align}
   f(\pi)
      &= E \left[ \lambda f_p(\pi) + (1-\lambda) f_x(\pi) \right] \\
   &= P_{\mbox{\scriptsize free}}(\pi)
      \left[ \lambda \hat{f}_p(\pi) + (1-\lambda) \hat{f}_x(\pi) \right]
      + (1-P_{\mbox{\scriptsize free}}(\pi))
      \left[ \lambda F_p + (1-\lambda) F_x \right]
\end{align}

Consider the the problem from Figure~\ref{fig:example-in-expectation}.
There are an infinite number of paths to the goal,
each consisting of walking along the sidewalk,
followed by crossing the street perpendicuarly at a particular
position $x$.
The sidewalk is known to be collision-free,
whereas each position on the street must be tested for collision
with obstacles with planning validation cost $\hat{f}_p(\pi)$
independent of $x$.
Execution cost $f_x(\pi)$ is given by $|x|+c$.

Suppose we first test walking straight across the street $\pi_0$
(knowing nothing, this is clearly the optimistically cheapest path)
and this is deemed in collision.
Which path should we consider next (e.g $\pi_a$ or $\pi_b$)?

What is our model for $P_{\mbox{\scriptsize free}}(\pi)$?
Radial basis functions.

We are operating under assumptions:
\begin{itemize}
\item Single-shot greedy (won't choose \emph{sets} of paths
   which minimize remaining effort)
\item Operates over \emph{paths} instead of configurations
   or edges (won't probe points, no explicit exploration)
\end{itemize}

\begin{figure}
   \begin{center}
   \includegraphics{build/example-in-expectation}
   \end{center}
   \caption{Simple example problem to illustrate optimizing
      remaining ensemble cost in expectation.}
   \label{fig:example-in-expectation}
\end{figure}

\subsection{What types of multi-set structure is the Multi-Set PRM
   well-suited to, and what not?}
\label{ques:multi-set-suited}

See Chapter~\ref{chap:multi-set-prm}.

\subsection{How should the \textsc{Proteus} task planner
   sample roots in multi-step problems?}
\label{ques:how-sequence}

See Chapter~\ref{chap:task-planning}.

\subsection{How does the \textsc{Proteus} task planner
   compare experimentally to the BiRRT used at the DRC Trials?}
\label{ques:drc-compare}

See Chapter~\ref{chap:task-planning}.

\subsection{How does the \textsc{Proteus} task planner
   perform on everyday kitchen tasks by the \textsc{Herb} robot?}
\label{ques:herb-performance}

See Chapter~\ref{chap:task-planning}.

}%for custom Q1 subsection numbering

\section{Timeline}

See this table for the timeline.

\begin{center}
\begin{tabular}{lll}
\hline
Topic & Sec. & Deadline \\
\hline
Greedy PRM, Multi-Set Planning & & January 2015 (RSS) (completed) \\
Proposal & & February 2015 \\
The Greedy PRM: Optimizing Total Task Cost & & March 2015 (IROS) \\
DRC Integration & & April-May 2015 \\
Multi-Set Planning at the DRC & & June 2015 (Humanoids) \\
Bored Robots: Hypothesized Conservative Volumes & & October 2015 (ICRA) \\
Writing & & November 2015 \\
Defence & & December 2015 \\
\hline
\end{tabular}
\end{center}

\section{Open-Source Software}

\begin{itemize}
\item Release implementation of checkmask PRM (OMPL)
\item Release implementation of multi-set decomposer (OpenRAVE+OMPL)
\item Re-release orcdchomp with permissive license?
\end{itemize}


{\small
\bibliographystyle{abbrv}
\bibliography{pr-refs}
}

\appendix
\chapter{Graph Search Proofs}
\label{appendix:gs-proofs}

This appendix presents some proofs relating the path-centric treatment
of graph search from Chapter~\ref{chap:inflate}
to traditional algorithms (e.g. A$^*$).

\begin{invariant}
The optimistically optimal path $path^* = A_s(G)$ can always be
segmented into
(a) a first sequence comprised of zero or more evaluated edges,
followed by
(b) a second sequence comprised of zero or more non-evaluated edges.
\label{inv:path-segmentation}
\end{invariant}

\begin{theorem}
Invariant~\ref{inv:path-segmentation} holds throughout the course of
$E_s$ [forward] (Algorithm~WHAT?).
\label{thm:seg-fwd}
\end{theorem}

\begin{proof}
At the first iteration, with no edges evaluated,
$path^*$ will contain only non-evaluated edges,
and the invariant trivially holds.

Consider the case where the invariant newly does not hold for $path^*$.
In this case, there exists at least one triple of adjacent vertices
on the path $v_a, v_b, v_c$
such that the edge $(v_a, v_b)$ is un-evaluated,
while the edge $(v_b, v_c)$ has been evaluated.
Due to our invariant,
there must have been some previous iteration which returned a
$path'^*$ which contained the triple
$v'_a, v_b, v_c$ for some other $v'_a$,
with $(v'_a, v_b)$ evaluated.
Therefore, the shortest distance to $v_b$ must known (and can be
reached through $v'_a$),
and any subsequent optimistic-optimal path through $v_b$
must consist of only evaluated segments until $v_b$
(due to the way $A_s$ breaks ties).
But our current $path^*$'s segment $(v_a, v_b)$ is un-evaluated!
This contradiction shows that the invariant must hold throughout the
algorithm.
\end{proof}

\end{document}
