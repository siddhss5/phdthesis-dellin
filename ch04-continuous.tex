\chapter{Roadmaps in Continuous Spaces}
\label{chap:graphs-in-continuous}

Sweet, sweet chapter about how to best embed explicit graphs
in continuous configuration spaces.

In this chapter,
we'll primarly focus on single-query things,
but we'll keep in mind that we want things that can enable reuse eventually.

\section{Review of Alternative Approaches}
\label{sec:related-work}

Since $C$ is continuous,
all approaches must introduce some sort of discretization
in order to compute solutions.
We choose to build a graph consisting of vertices and edges in $C$,
and then search that graph (Section~\ref{sec:best-first}).
We do this because we can rely on existing techniques,
and because an explicit graph can be more easily reused than other
approaches.
In this section, we discuss alternative approaches to solving
the motion planning problem for articulated robots.

\subsection{Multi-Query Approaches}

We could run a PRM \cite{kavrakietal1996prm}.
Commit to a fixed graph,
and determine the validity of each vertex and edge w.r.t.
$\mathcal{C}_{\mbox{\scriptsize free}}$.
Then, at query time,
run A* to find the shortest path (this is fast due to graph sparseness).
This is good because it reuses work.
Unfortunately,
(a) our $\mathcal{C}_{\mbox{\scriptsize free}}$
is different for every subplan
(and for different options with each),
and (b) we don't want to determine validity over the entire graph
because it's costly.

\subsection{Anytime algorithms}

Compare to RRT*, FMT*, BIT*, etc.

\subsection{Other}

Need to look into the SBL planner \cite{sanchezante2001sbl}
(Single Query BiDirectional Lazy PRM).

\subsection{Incremental Construction Algorithms}

We could construct the graph incrementally and in response to the shape
of $\mathcal{C}_{\mbox{\scriptsize free}}$.
RRTs behave well for quickly finding feasible paths.
We'll compare against them at the end of this chapter.
Also talk about ESTs.
Difficult to cache things.

\subsection{Trajectory Optimization}

One approach is trajectory optimization.
For example, there's CHOMP \cite{zucker2013chomp}
and TrajOpt \cite{schulman2013trajopt}.
Lots of other prior work here that is not manipulation-focused.

Local minima problems.
Difficult to cache / apply to similar problems.

This is largely complementary.
Use sampling-based planning to quickly find feasible solutions,
and then optimize them.

\section{Types of Graphs}

\begin{itemize}
\item Probabalistic vs lattice-based graphs.
\item Probabalistic (pseudo-random) for efficient caching.
\end{itemize}

\section{Optimization in Expectation}

Extend the E$^8$-PRM algorithm to do things in expectation.

Relate to Evan's work.

Motivate the incremental densification idea,
with a graduated cost model
to approximate a probabalistic model
of the $\mathcal{C}$-space.

\section{Batching}

Choosing Batch Size $N$.
See Algorithm~\ref{alg:batched-e8}.

\begin{algorithm}
\caption{Batched-E$^8$ Planner}
\label{alg:batched-e8}
\begin{algorithmic}[1]
\Procedure {Batched-E$^8$}{$G, \mathcal{Q}, N, \lambda$}
%\State $G.V \leftarrow \emptyset$
%\State $G.E \leftarrow \emptyset$
\Loop
   \State \textsc{PrmAddSamples}($G, \mathcal{Q}, N$)
   \State Run E$^8$ ...
\EndLoop
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Partial Path Evaluation}
\label{alg:path-evaluation}
\begin{algorithmic}[1]
\Function {\textsc{EvalPath}}{$\pi$}
   \ForAll {$e \in \pi$}
         \label{line:edge-evaluation-order}
      \State $(S_{plan}, b_{plan}, c_{plan})
         = \mbox{\textsc{OptEdgePlan}}(e)$
      \ForAll {$X \in S_{plan}$}
         \State $b_{act} = \mathbf{1}_X[e]$
         \State $\arraycolsep=2pt
            e.P \leftarrow e.P \cup
            \left\{\left( \begin{array}{rl}
            \mathbf{1}_X & \mbox{if } b_{act} \\
            \lnot \mathbf{1}_X & \mbox{otherwise} \\
            \end{array} \right)
            \right\}$
         \If {$b_{act} \neq b_{plan}(X)$}
            \State \Return False
         \EndIf
      \EndFor
   \EndFor
   \State \Return True
\EndFunction
\end{algorithmic}
\end{algorithm}

The E$^8$-PRM (Algorithm~\ref{alg:e8})
operates on an initially empty persistent roadmap graph $G$.
Each vertex represents a configuration $x \in \mathcal{C}$,
and each edge represents a path $x(t)$ planned by a local planner.
Similarly to the LazyPRM,
edges are not evaluated until necessary.

The E$^8$-PRM proceeds in \emph{batches};
at the start of each batch,
the \textsc{PrmAddSamples} procedure adds
$N$ additional vertices to the graph sampled from $\mathcal{C}$
(including sampled start and goal configurations from $\mathcal{Q}$
if not yet present),
and edges are generated according to the PRM construction method.
The E$^8$-PRM does not commit to any particular such method
(e.g. r-disk, K-nearest-neighbors).

What graph are we searching over?
If it's too sparse, we'll stop after knowing that no solution exists.
If it's too dense, we'll spend too much time filling in parts of
space.
There's actually some spatial relationship in
$\mathcal{C}_{\mbox{\scriptsize free}}$ what we're not
modeling.
We get around this with artificial sparseness.
There's definitely a paper's worth of work here too (Shushman's stuff).
The easy version is with sequential batches of size $N$.
Talk about how what we really want to do
is evaluate the estimate of cost remaining
\emph{in expectation}.

Talk about how this is complementary to BIT* which acheive speedups
by batching, not by inflating.

Relate to Markov Random Fields and two-class image segmentation
which capture spatial correlation.

\section{Whole-Path Bisection Testing}

We implement the indicator functionals $\mathbf{1}_X[x(t)]$
approximately by evaluating the corresponding indicator functions
$\mathbf{1}_X(x)$ at a fixed resolution along the path.

Sidd wants me to play with Hauser's fast bounded-velocity,
bounded-acceleration segment timing code
(which starts and stops at each waypoint).

Also talk here about the fancy Lazy PRM path bisection
evaluation function.

\section{The E$^8$-PRM}

This is the planner in continuous spaces,
requires a planning cost model for each edge.

\subsection{Implementation Details}
\label{subsec:implementation-details}

We provide an implementation of the E$^8$-PRM
as a plugin for the Open Motion Planning Library \cite{sucan2012ompl}.%
\footnote{Not available during the anonymous review process.}
Here, we discuss a few relevant details of the implementation.

\section{Relaxing the Additive Cost Model Requirement}

Could we do this?
We lose the nice efficient LPA*-enabling structure in
E$^8$ this way,
but it lets us incorporate a more accurate cost model in some domains,
especially for execution costs for fast motions (e.g. total time).

\section{Future Work}

How to handle the narrow passage problem?
Lots of literature on that, new sampling strategies, etc.
(Toggle PRM, for instance.)
